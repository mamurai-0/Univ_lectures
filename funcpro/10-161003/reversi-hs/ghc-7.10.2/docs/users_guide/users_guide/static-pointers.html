<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>7.21. Static pointers</title><link rel="stylesheet" type="text/css" href="fptools.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.10.2"><link rel="up" href="ghc-language-features.html" title="Chapter 7. GHC Language Features"><link rel="prev" href="assertions.html" title="7.20. Assertions"><link rel="next" href="pragmas.html" title="7.22. Pragmas"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.21. Static pointers

</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="assertions.html">Prev</a> </td><th width="60%" align="center">Chapter 7. GHC Language Features</th><td width="20%" align="right"> <a accesskey="n" href="pragmas.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="static-pointers"></a>7.21. Static pointers
<a class="indexterm" name="idm317743457968"></a>
</h2></div></div></div><p>
The language extension <code class="literal">-XStaticPointers</code> adds a new
syntactic form <code class="literal">static <em class="replaceable"><code>e</code></em></code>,
which stands for a reference to the closed expression
<em class="replaceable"><code>e</code></em>. This reference is stable and portable,
in the sense that it remains valid across different processes on
possibly different machines. Thus, a process can create a reference
and send it to another process that can resolve it to
<em class="replaceable"><code>e</code></em>.
</p><p>
With this extension turned on, <code class="literal">static</code> is no longer
a valid identifier.
</p><p>
Static pointers were first proposed in the paper <a class="ulink" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/remote.pdf" target="_top">
Towards Haskell in the cloud</a>, Jeff Epstein, Andrew P. Black and Simon
Peyton-Jones, Proceedings of the 4th ACM Symposium on Haskell, pp.
118-129, ACM, 2011.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="using-static-pointers"></a>7.21.1. Using static pointers</h3></div></div></div><p>
Each reference is given a key which can be used to locate it at runtime with
<a class="ulink" href="../libraries/base-4.8.1.0/GHC.StaticPtr.html#v%3AunsafeLookupStaticPtr" target="_top"><code class="literal">unsafeLookupStaticPtr</code></a>
which uses a global and immutable table called the Static Pointer Table.
The compiler includes entries in this table for all static forms found in
the linked modules. The value can be obtained from the reference via
<a class="ulink" href="../libraries/base-4.8.1.0/GHC.StaticPtr.html#v%3AdeRefStaticPtr" target="_top"><code class="literal">deRefStaticPtr</code></a>
</p><p>
The body <code class="literal">e</code> of a <code class="literal">static
e</code> expression must be a closed expression. That is, there can
be no free variables occurring in <code class="literal">e</code>, i.e. lambda-
or let-bound variables bound locally in the context of the expression.
</p><p>
All of the following are permissible:
</p><pre class="programlisting">
inc :: Int -&gt; Int
inc x = x + 1

ref1 = static 1
ref2 = static inc
ref3 = static (inc 1)
ref4 = static ((\x -&gt; x + 1) (1 :: Int))
ref5 y = static (let x = 1 in x)
</pre><p>
While the following definitions are rejected:
</p><pre class="programlisting">
ref6 = let x = 1 in static x
ref7 y = static (let x = 1 in y)
</pre><p>
</p></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="typechecking-static-pointers"></a>7.21.2. Static semantics of static pointers</h3></div></div></div><p>

Informally, if we have a closed expression
</p><pre class="programlisting">
e :: forall a_1 ... a_n . t
</pre><p>
the static form is of type
</p><pre class="programlisting">
static e :: (Typeable a_1, ... , Typeable a_n) =&gt; StaticPtr t
</pre><p>
Furthermore, type <code class="literal">t</code> is constrained to have a
<code class="literal">Typeable</code> instance.

The following are therefore illegal:
</p><pre class="programlisting">
static show                    -- No Typeable instance for (Show a =&gt; a -&gt; String)
static Control.Monad.ST.runST  -- No Typeable instance for ((forall s. ST s a) -&gt; a)
</pre><p>

That being said, with the appropriate use of wrapper datatypes, the
above limitations induce no loss of generality:
</p><pre class="programlisting">
{-# LANGUAGE ConstraintKinds           #-}
{-# LANGUAGE DeriveDataTypeable        #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE Rank2Types                #-}
{-# LANGUAGE StandaloneDeriving        #-}
{-# LANGUAGE StaticPointers            #-}

import Control.Monad.ST
import Data.Typeable
import GHC.StaticPtr

data Dict c = c =&gt; Dict
  deriving Typeable

g1 :: Typeable a =&gt; StaticPtr (Dict (Show a) -&gt; a -&gt; String)
g1 = static (\Dict -&gt; show)

data Rank2Wrapper f = R2W (forall s. f s)
  deriving Typeable
newtype Flip f a s = Flip { unFlip :: f s a }
  deriving Typeable

g2 :: Typeable a =&gt; StaticPtr (Rank2Wrapper (Flip ST a) -&gt; a)
g2 = static (\(R2W f) -&gt; runST (unFlip f))
</pre><p>
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="assertions.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ghc-language-features.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="pragmas.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.20. Assertions

 </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.22. Pragmas</td></tr></table></div></body></html>
