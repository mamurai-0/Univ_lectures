<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>7.15. Partial Type Signatures</title><link rel="stylesheet" type="text/css" href="fptools.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.10.2"><link rel="up" href="ghc-language-features.html" title="Chapter 7. GHC Language Features"><link rel="prev" href="typed-holes.html" title="7.14. Typed Holes"><link rel="next" href="defer-type-errors.html" title="7.16. Deferring type errors to runtime"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.15. Partial Type Signatures</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="typed-holes.html">Prev</a> </td><th width="60%" align="center">Chapter 7. GHC Language Features</th><td width="20%" align="right"> <a accesskey="n" href="defer-type-errors.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="partial-type-signatures"></a>7.15. Partial Type Signatures</h2></div></div></div><p>
A partial type signature is a type signature containing special placeholders
written with a leading underscore (e.g., "<code class="literal">_</code>",
"<code class="literal">_foo</code>", "<code class="literal">_bar</code>") called
<span class="emphasis"><em>wildcards</em></span>. Partial type signatures are to type signatures
what <a class="xref" href="typed-holes.html" title="7.14. Typed Holes">Section 7.14, &#8220;Typed Holes&#8221;</a> are to expressions. During compilation these
wildcards or holes will generate an error message that describes which type
was inferred at the hole's location, and information about the origin of any
free type variables. GHC reports such error messages by default.</p><p>
Unlike <a class="xref" href="typed-holes.html" title="7.14. Typed Holes">Section 7.14, &#8220;Typed Holes&#8221;</a>, which make the program incomplete and
will generate errors when they are evaluated, this needn't be the case for
holes in type signatures. The type checker is capable (in most cases) of
type-checking a binding with or without a type signature. A partial type
signature bridges the gap between the two extremes, the programmer can choose
which parts of a type to annotate and which to leave over to the type-checker
to infer.
</p><p>
By default, the type-checker will report an error message for each hole in a
partial type signature, informing the programmer of the inferred type. When
the <code class="option">-XPartialTypeSignatures</code> flag is enabled, the type-checker
will accept the inferred type for each hole, generating warnings instead of
errors. Additionally, these warnings can be silenced with the
<code class="option">-fno-warn-partial-type-signatures</code> flag.
</p><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="pts-syntax"></a>7.15.1. Syntax</h3></div></div></div><p>
A (partial) type signature has the following form: <code class="literal">forall a b .. .
(C1, C2, ..) =&gt; tau</code>. It consists of three parts:
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">The type variables: <code class="literal">a b ..</code></li><li class="listitem">The constraints: <code class="literal">(C1, C2, ..)</code></li><li class="listitem">The (mono)type: <code class="literal">tau</code></li></ul></div><p>
We distinguish three kinds of wildcards.
</p><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="type-wildcards"></a>7.15.1.1. Type Wildcards</h4></div></div></div><p>
Wildcards occurring within the monotype (tau) part of the type signature are
<span class="emphasis"><em>type wildcards</em></span> ("type" is often omitted as this is the
default kind of wildcard). Type wildcards can be instantiated to any monotype
like <code class="literal">Bool</code> or <code class="literal">Maybe [Bool]</code>, including
functions and higher-kinded types like <code class="literal">(Int -&gt; Bool)</code> or
<code class="literal">Maybe</code>.
</p><pre class="programlisting">
not' :: Bool -&gt; _
not' x = not x
-- Inferred: Bool -&gt; Bool

maybools :: _
maybools = Just [True]
-- Inferred: Maybe [Bool]

just1 :: _ Int
just1 = Just 1
-- Inferred: Maybe Int

filterInt :: _ -&gt; _ -&gt; [Int]
filterInt = filter -- has type forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
-- Inferred: (Int -&gt; Bool) -&gt; [Int] -&gt; [Int]
</pre><p>
For instance, the first wildcard in the type signature <code class="literal">not'</code>
would produce the following error message:
</p><pre class="programlisting">
Test.hs:4:17:
    Found hole &#8216;_&#8217; with type: Bool
    To use the inferred type, enable PartialTypeSignatures
    In the type signature for &#8216;not'&#8217;: Bool -&gt; _
</pre><p>
When a wildcard is not instantiated to a monotype, it will be generalised
over, i.e. replaced by a fresh type variable (of which the name will often
start with <code class="literal">w_</code>), e.g.
</p><pre class="programlisting">
foo :: _ -&gt; _
foo x = x
-- Inferred: forall w_. w_ -&gt; w_

filter' :: _
filter' = filter -- has type forall a. (a -&gt; Bool) -&gt; [a] -&gt; [a]
-- Inferred: (a -&gt; Bool) -&gt; [a] -&gt; [a]
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="named-wildcards"></a>7.15.1.2. Named Wildcards</h4></div></div></div><p>
Type wildcards can also be named by giving the underscore an identifier as
suffix, i.e. <code class="literal">_a</code>. These are called <span class="emphasis"><em>named
wildcards</em></span>. All occurrences of the same named wildcard within one
type signature will unify to the same type. For example:
</p><pre class="programlisting">
f :: _x -&gt; _x
f ('c', y) = ('d', error "Urk")
-- Inferred: forall t. (Char, t) -&gt; (Char, t)
</pre><p>
The named wildcard forces the argument and result types to be the same.
Lacking a signature, GHC would have inferred <code class="literal">forall a b. (Char, a) -&gt;
(Char, b)</code>. A named wildcard can be mentioned in constraints,
provided it also occurs in the monotype part of the type signature to make
sure that it unifies with something:
</p><pre class="programlisting">
somethingShowable :: Show _x =&gt; _x -&gt; _
somethingShowable x = show x
-- Inferred type: Show w_x =&gt; w_x -&gt; String

somethingShowable' :: Show _x =&gt; _x -&gt; _
somethingShowable' x = show (not x)
-- Inferred type: Bool -&gt; String
</pre><p>
Besides an extra-constraints wildcard (see <a class="xref" href="partial-type-signatures.html#extra-constraints-wildcard" title="7.15.1.3. Extra-Constraints Wildcard">Section 7.15.1.3, &#8220;Extra-Constraints Wildcard&#8221;</a>), only named wildcards can occur in the
constraints, e.g. the <code class="literal">_x</code> in <code class="literal">Show _x</code>.
</p><p>
Named wildcards <span class="emphasis"><em>should not be confused with type
variables</em></span>. Even though syntactically similar, named wildcards can
unify with monotypes as well as be generalised over (and behave as type
variables).</p><p>
In the first example above, <code class="literal">_x</code> is generalised over (and is
effectively replaced by a fresh type variable <code class="literal">w_x</code>). In the
second example, <code class="literal">_x</code> is unified with the
<code class="literal">Bool</code> type, and as <code class="literal">Bool</code> implements the
<code class="literal">Show</code> type class, the constraint <code class="literal">Show
Bool</code> can be simplified away.
</p><p>
By default, GHC (as the Haskell 2010 standard prescribes) parses identifiers
starting with an underscore in a type as type variables. To treat them as
named wildcards, the <code class="option">-XNamedWildCards</code> flag should be enabled.
The example below demonstrated the effect.
</p><pre class="programlisting">
foo :: _a -&gt; _a
foo _ = False
</pre><p>
Compiling this program without enabling <code class="option">-XNamedWildCards</code>
produces the following error message complaining about the type variable
<code class="literal">_a</code> no matching the actual type <code class="literal">Bool</code>.
</p><pre class="programlisting">
Test.hs:5:9:
    Couldn't match expected type &#8216;_a&#8217; with actual type &#8216;Bool&#8217;
      &#8216;_a&#8217; is a rigid type variable bound by
           the type signature for foo :: _a -&gt; _a at Test.hs:4:8
    Relevant bindings include foo :: _a -&gt; _a (bound at Test.hs:4:1)
    In the expression: False
    In an equation for &#8216;foo&#8217;: foo _ = False
</pre><p>
Compiling this program with <code class="option">-XNamedWildCards</code> enabled produces
the following error message reporting the inferred type of the named wildcard
<code class="literal">_a</code>.
</p><pre class="programlisting">
Test.hs:4:8: Warning:
    Found hole &#8216;_a&#8217; with type: Bool
    In the type signature for &#8216;foo&#8217;: _a -&gt; _a
</pre></div><div class="sect3"><div class="titlepage"><div><div><h4 class="title"><a name="extra-constraints-wildcard"></a>7.15.1.3. Extra-Constraints Wildcard</h4></div></div></div><p>
The third kind of wildcard is the <span class="emphasis"><em>extra-constraints
wildcard</em></span>. The presence of an extra-constraints wildcard indicates
that an arbitrary number of extra constraints may be inferred during type
checking and will be added to the type signature. In the example below, the
extra-constraints wildcard is used to infer three extra constraints.
</p><pre class="programlisting">
arbitCs :: _ =&gt; a -&gt; String
arbitCs x = show (succ x) ++ show (x == x)
-- Inferred:
--   forall a. (Enum a, Eq a, Show a) =&gt; a -&gt; String
-- Error:
Test.hs:5:12:
    Found hole &#8216;_&#8217; with inferred constraints: (Enum a, Eq a, Show a)
    To use the inferred type, enable PartialTypeSignatures
    In the type signature for &#8216;arbitCs&#8217;: _ =&gt; a -&gt; String
</pre><p>
An extra-constraints wildcard shouldn't prevent the programmer from already
listing the constraints he knows or wants to annotate, e.g.
</p><pre class="programlisting">
-- Also a correct partial type signature:
arbitCs' :: (Enum a, _) =&gt; a -&gt; String
arbitCs' x = arbitCs x
-- Inferred:
--   forall a. (Enum a, Show a, Eq a) =&gt; a -&gt; String
-- Error:
Test.hs:9:22:
    Found hole &#8216;_&#8217; with inferred constraints: (Eq a, Show a)
    To use the inferred type, enable PartialTypeSignatures
    In the type signature for &#8216;arbitCs'&#8217;: (Enum a, _) =&gt; a -&gt; String
</pre><p>
An extra-constraints wildcard can also lead to zero extra constraints to be
inferred, e.g.
</p><pre class="programlisting">
noCs :: _ =&gt; String
noCs = "noCs"
-- Inferred: String
-- Error:
Test.hs:13:9:
    Found hole &#8216;_&#8217; with inferred constraints: ()
    To use the inferred type, enable PartialTypeSignatures
    In the type signature for &#8216;noCs&#8217;: _ =&gt; String
</pre><p>
As a single extra-constraints wildcard is enough to infer any number of
constraints, only one is allowed in a type signature and it should come last
in the list of constraints.
</p><p>
Extra-constraints wildcards cannot be named.
</p></div></div><div class="sect2"><div class="titlepage"><div><div><h3 class="title"><a name="pts-where"></a>7.15.2. Where can they occur?</h3></div></div></div><p>
Partial type signatures are allowed for bindings, pattern and expression signatures.
In all other contexts, e.g. type class or type family declarations, they are disallowed.
In the following example a wildcard is used in each of the three possible contexts.
</p><pre class="programlisting">
{-# LANGUAGE ScopedTypeVariables #-}
foo :: _
foo (x :: _) = (x :: _)
-- Inferred: forall w_. w_ -&gt; w_
</pre></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="typed-holes.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ghc-language-features.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="defer-type-errors.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">7.14. Typed Holes </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 7.16. Deferring type errors to runtime</td></tr></table></div></body></html>
