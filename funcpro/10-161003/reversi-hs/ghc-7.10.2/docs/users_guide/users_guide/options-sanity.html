<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>4.8. Warnings and sanity-checking</title><link rel="stylesheet" type="text/css" href="fptools.css"><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"><link rel="home" href="index.html" title="The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.10.2"><link rel="up" href="using-ghc.html" title="Chapter 4. Using GHC"><link rel="prev" href="separate-compilation.html" title="4.7. Filenames and separate compilation"><link rel="next" href="packages.html" title="4.9.  Packages"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.8. Warnings and sanity-checking</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="separate-compilation.html">Prev</a> </td><th width="60%" align="center">Chapter 4. Using GHC</th><td width="20%" align="right"> <a accesskey="n" href="packages.html">Next</a></td></tr></table><hr></div><div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="options-sanity"></a>4.8. Warnings and sanity-checking</h2></div></div></div><a class="indexterm" name="idm317757755344"></a><a class="indexterm" name="idm317757754576"></a><p>GHC has a number of options that select which types of
    non-fatal error messages, otherwise known as warnings, can be
    generated during compilation.  By default, you get a standard set
    of warnings which are generally likely to indicate bugs in your
    program.  These are:
    <code class="option">-fwarn-overlapping-patterns</code>,
    <code class="option">-fwarn-warnings-deprecations</code>,
    <code class="option">-fwarn-deprecated-flags</code>,
    <code class="option">-fwarn-unrecognised-pragmas</code>,
    <code class="option">-fwarn-pointless-pragmas</code>,
    <code class="option">-fwarn-duplicate-constraints</code>,
    <code class="option">-fwarn-duplicate-exports</code>,
    <code class="option">-fwarn-overflowed-literals</code>,
    <code class="option">-fwarn-empty-enumerations</code>,
    <code class="option">-fwarn-missing-fields</code>,
    <code class="option">-fwarn-missing-methods</code>,
    <code class="option">-fwarn-wrong-do-bind</code>,
    <code class="option">-fwarn-unsupported-calling-conventions</code>,
    <code class="option">-fwarn-dodgy-foreign-imports</code>,
    <code class="option">-fwarn-inline-rule-shadowing</code>,
    <code class="option">-fwarn-unsupported-llvm-version</code>,
    <code class="option">-fwarn-context-quantification</code>, and
    <code class="option">-fwarn-tabs</code>.
    The following flags are simple ways to select standard
    &#8220;packages&#8221; of warnings:
    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-W</code>:</span></dt><dd><a class="indexterm" name="idm317757743744"></a><p>Provides the standard warnings plus
          <code class="option">-fwarn-unused-binds</code>,
          <code class="option">-fwarn-unused-matches</code>,
          <code class="option">-fwarn-unused-imports</code>,
          <code class="option">-fwarn-incomplete-patterns</code>,
          <code class="option">-fwarn-dodgy-exports</code>, and
          <code class="option">-fwarn-dodgy-imports</code>.</p></dd><dt><span class="term"><code class="option">-Wall</code>:</span></dt><dd><a class="indexterm" name="idm317757738544"></a><p>Turns on all warning options that indicate potentially
          suspicious code.  The warnings that are
          <span class="emphasis"><em>not</em></span> enabled by <code class="option">-Wall</code>
          are
            <code class="option">-fwarn-incomplete-uni-patterns</code>,
            <code class="option">-fwarn-incomplete-record-updates</code>,
            <code class="option">-fwarn-monomorphism-restriction</code>,
            <code class="option">-fwarn-auto-orphans</code>,
            <code class="option">-fwarn-implicit-prelude</code>,
            <code class="option">-fwarn-missing-local-sigs</code>,
            <code class="option">-fwarn-missing-exported-sigs</code>,
            <code class="option">-fwarn-missing-import-lists</code> and
            <code class="option">-fwarn-identities</code>.</p></dd><dt><span class="term"><code class="option">-w</code>:</span></dt><dd><a class="indexterm" name="idm317757730960"></a><p>Turns off all warnings, including the standard ones and
      those that <code class="literal">-Wall</code> doesn't enable.</p></dd><dt><span class="term"><code class="option">-Werror</code>:</span></dt><dd><a class="indexterm" name="idm317757727600"></a><p>Makes any warning into a fatal error. Useful so that you don't
            miss warnings when doing batch compilation. </p></dd><dt><span class="term"><code class="option">-Wwarn</code>:</span></dt><dd><a class="indexterm" name="idm317757724768"></a><p>Warnings are treated only as warnings, not as errors. This is
            the default, but can be useful to negate a
        <code class="option">-Werror</code> flag.</p></dd></dl></div><p>The full set of warning options is described below.  To turn
    off any warning, simply give the corresponding
    <code class="option">-fno-warn-...</code> option on the command line.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-fwarn-typed-holes</code>:</span></dt><dd><a class="indexterm" name="idm317757720176"></a><a class="indexterm" name="idm317757719136"></a><p>
              Determines whether the compiler reports typed holes warnings. Has
              no effect unless typed holes errors are deferred until runtime.
              See <a class="xref" href="typed-holes.html" title="7.14. Typed Holes">Section 7.14, &#8220;Typed Holes&#8221;</a> and <a class="xref" href="defer-type-errors.html" title="7.16. Deferring type errors to runtime">Section 7.16, &#8220;Deferring type errors to runtime&#8221;</a>
            </p><p>This warning is on by default.</p></dd><dt><span class="term"><code class="option">-fdefer-type-errors</code>:</span></dt><dd><a class="indexterm" name="idm317757714704"></a><a class="indexterm" name="idm317757713664"></a><p>Defer as many type errors as possible until runtime.  
            At compile time you get a warning (instead of an error).  At 
            runtime, if you use a value that depends on a type error, you 
            get a runtime error; but you can run any type-correct parts of your code 
            just fine.  See <a class="xref" href="defer-type-errors.html" title="7.16. Deferring type errors to runtime">Section 7.16, &#8220;Deferring type errors to runtime&#8221;</a></p></dd><dt><span class="term"><code class="option">-fdefer-typed-holes</code>:</span></dt><dd><a class="indexterm" name="idm317757710256"></a><a class="indexterm" name="idm317757709216"></a><p>
              Defer typed holes errors until runtime. This will turn the errors
              produced by typed holes into
              warnings. Using a value that depends on a typed hole produces a
              runtime error, the same as <code class="option">-fdefer-type-errors</code>
              (which implies this option). See <a class="xref" href="typed-holes.html" title="7.14. Typed Holes">Section 7.14, &#8220;Typed Holes&#8221;</a>
              and <a class="xref" href="defer-type-errors.html" title="7.16. Deferring type errors to runtime">Section 7.16, &#8220;Deferring type errors to runtime&#8221;</a>.
          </p><p>
              Implied by <code class="option">-fdefer-type-errors</code>. See also
              <code class="option">-fwarn-typed-holes</code>.
          </p></dd><dt><span class="term"><code class="option">-fwarn-partial-type-signatures</code>:</span></dt><dd><a class="indexterm" name="idm317757702672"></a><a class="indexterm" name="idm317757701632"></a><p>
              Determines whether the compiler reports holes in partial type
              signatures as warnings. Has no effect unless
              <code class="option">-XPartialTypeSignatures</code> is enabled, which
              controls whether errors should be generated for holes in types
              or not. See <a class="xref" href="partial-type-signatures.html" title="7.15. Partial Type Signatures">Section 7.15, &#8220;Partial Type Signatures&#8221;</a>.
            </p><p>This warning is on by default.</p></dd><dt><span class="term"><code class="option">-fhelpful-errors</code>:</span></dt><dd><a class="indexterm" name="idm317757697280"></a><a class="indexterm" name="idm317757696240"></a><p>When a name or package is not found in scope, make
            suggestions for the name or package you might have meant instead.</p><p>This option is on by default.</p></dd><dt><span class="term"><code class="option">-fwarn-unrecognised-pragmas</code>:</span></dt><dd><a class="indexterm" name="idm317757693088"></a><a class="indexterm" name="idm317757692048"></a><a class="indexterm" name="idm317757691280"></a><p>Causes a warning to be emitted when a
          pragma that GHC doesn't recognise is used. As well as pragmas
      that GHC itself uses, GHC also recognises pragmas known to be used
      by other tools, e.g. <code class="literal">OPTIONS_HUGS</code> and
      <code class="literal">DERIVE</code>.</p><p>This option is on by default.</p></dd><dt><span class="term"><code class="option">-fwarn-pointless-pragmas</code>:</span></dt><dd><a class="indexterm" name="idm317757686752"></a><a class="indexterm" name="idm317757685712"></a><a class="indexterm" name="idm317757684944"></a><p>Causes a warning to be emitted when GHC detects that a
          module contains a pragma that has no effect.</p><p>This option is on by default.</p></dd><dt><span class="term"><code class="option">-fwarn-warnings-deprecations</code>:</span></dt><dd><a class="indexterm" name="idm317757681824"></a><a class="indexterm" name="idm317757680784"></a><a class="indexterm" name="idm317757680016"></a><p>Causes a warning to be emitted when a
          module, function or type with a WARNING or DEPRECATED pragma
      is used. See <a class="xref" href="pragmas.html#warning-deprecated-pragma" title="7.22.4. WARNING and DEPRECATED pragmas">Section 7.22.4, &#8220;WARNING and DEPRECATED pragmas&#8221;</a> for more
      details on the pragmas.</p><p>This option is on by default.</p></dd><dt><span class="term"><code class="option">-fwarn-amp</code>:</span></dt><dd><a class="indexterm" name="idm317757676112"></a><a class="indexterm" name="idm317757675088"></a><a class="indexterm" name="idm317757674336"></a><p>Causes a warning to be emitted when a definition
          is in conflict with the AMP (Applicative-Monad proosal),
          namely:
          1. Instance of Monad without Applicative;
          2. Instance of MonadPlus without Alternative;
          3. Custom definitions of join/pure/&lt;*&gt;</p><p>This option is on by default.</p></dd><dt><span class="term"><code class="option">-fwarn-deprecated-flags</code>:</span></dt><dd><a class="indexterm" name="idm317757670720"></a><a class="indexterm" name="idm317757669680"></a><p>Causes a warning to be emitted when a deprecated
          commandline flag is used.</p><p>This option is on by default.</p></dd><dt><span class="term"><code class="option">-fwarn-unsupported-calling-conventions</code>:</span></dt><dd><a class="indexterm" name="idm317757666544"></a><p>Causes a warning to be emitted for foreign declarations
          that use unsupported calling conventions. In particular,
          if the <code class="literal">stdcall</code> calling convention is used
          on an architecture other than i386 then it will be treated
          as <code class="literal">ccall</code>.</p></dd><dt><span class="term"><code class="option">-fwarn-dodgy-foreign-imports</code>:</span></dt><dd><a class="indexterm" name="idm317757662128"></a><p>Causes a warning to be emitted for foreign imports of
          the following form:</p><pre class="programlisting">
foreign import "f" f :: FunPtr t
</pre><p>on the grounds that it probably should be</p><pre class="programlisting">
foreign import "&amp;f" f :: FunPtr t
</pre><p>The first form declares that `f` is a (pure) C
          function that takes no arguments and returns a pointer to a
          C function with type `t`, whereas the second form declares
          that `f` itself is a C function with type `t`.  The first
          declaration is usually a mistake, and one that is hard to
          debug because it results in a crash, hence this
          warning.</p></dd><dt><span class="term"><code class="option">-fwarn-dodgy-exports</code>:</span></dt><dd><a class="indexterm" name="idm317757656608"></a><p>Causes a warning to be emitted when a datatype
      <code class="literal">T</code> is exported
      with all constructors, i.e. <code class="literal">T(..)</code>, but is it
      just a type synonym.</p><p>Also causes a warning to be emitted when a module is
      re-exported, but that module exports nothing.</p></dd><dt><span class="term"><code class="option">-fwarn-dodgy-imports</code>:</span></dt><dd><a class="indexterm" name="idm317757651824"></a><p>Causes a warning to be emitted in the following cases:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>When a datatype <code class="literal">T</code> is imported with all
                constructors, i.e. <code class="literal">T(..)</code>, but has been
                exported abstractly, i.e. <code class="literal">T</code>.
              </p></li><li class="listitem"><p>When an <code class="literal">import</code> statement hides an
                entity that is not exported.</p></li></ul></div></dd><dt><span class="term"><code class="option">-fwarn-overflowed-literals</code>:</span></dt><dd><a class="indexterm" name="idm317757644160"></a><p>
              Causes a warning to be emitted if a literal will overflow,
              e.g. <code class="literal">300 :: Word8</code>.
          </p></dd><dt><span class="term"><code class="option">-fwarn-empty-enumerations</code>:</span></dt><dd><a class="indexterm" name="idm317757640544"></a><p>
              Causes a warning to be emitted if an enumeration is
              empty, e.g. <code class="literal">[5 .. 3]</code>.
          </p></dd><dt><span class="term"><code class="option">-fwarn-lazy-unlifted-bindings</code>:</span></dt><dd><a class="indexterm" name="idm317757636928"></a><p>This flag is a no-op, and will be removed in GHC 7.10.</p></dd><dt><span class="term"><code class="option">-fwarn-duplicate-constraints</code>:</span></dt><dd><a class="indexterm" name="idm317757634000"></a><a class="indexterm" name="idm317757633088"></a><p>Have the compiler warn about duplicate constraints in a type signature. For
          example
          </p><pre class="programlisting">
             f :: (Eq a, Show a, Eq a) =&gt; a -&gt; a
          </pre><p>
          The warning will indicate the duplicated <code class="literal">Eq a</code> constraint.
          </p><p>This option is on by default.</p></dd><dt><span class="term"><code class="option">-fwarn-duplicate-exports</code>:</span></dt><dd><a class="indexterm" name="idm317757628528"></a><a class="indexterm" name="idm317757627616"></a><a class="indexterm" name="idm317757626832"></a><p>Have the compiler warn about duplicate entries in
          export lists. This is useful information if you maintain
          large export lists, and want to avoid the continued export
          of a definition after you've deleted (one) mention of it in
          the export list.</p><p>This option is on by default.</p></dd><dt><span class="term"><code class="option">-fwarn-hi-shadowing</code>:</span></dt><dd><a class="indexterm" name="idm317757623520"></a><a class="indexterm" name="idm317757622608"></a><p>Causes the compiler to emit a warning when a module or
          interface file in the current directory is shadowing one
          with the same module name in a library or other
          directory.</p></dd><dt><span class="term"><code class="option">-fwarn-identities</code>:</span></dt><dd><a class="indexterm" name="idm317757619408"></a><p>Causes the compiler to emit a warning when a Prelude numeric
            conversion converts a type T to the same type T; such calls
            are probably no-ops and can be omitted.  The functions checked for
            are: <code class="literal">toInteger</code>,
            <code class="literal">toRational</code>,
            <code class="literal">fromIntegral</code>,
            and <code class="literal">realToFrac</code>.
          </p></dd><dt><span class="term"><code class="option">-fwarn-implicit-prelude</code>:</span></dt><dd><a class="indexterm" name="idm317757613792"></a><a class="indexterm" name="idm317757612880"></a><p>Have the compiler warn if the Prelude is implicitly
          imported.  This happens unless either the Prelude module is
          explicitly imported with an <code class="literal">import ... Prelude ...</code>
          line, or this implicit import is disabled (either by
          <code class="option">-XNoImplicitPrelude</code> or a
          <code class="literal">LANGUAGE NoImplicitPrelude</code> pragma).</p><p>Note that no warning is given for syntax that implicitly
          refers to the Prelude, even if <code class="option">-XNoImplicitPrelude</code>
          would change whether it refers to the Prelude.
          For example, no warning is given when
          <code class="literal">368</code> means
          <code class="literal">Prelude.fromInteger (368::Prelude.Integer)</code>
          (where <code class="literal">Prelude</code> refers to the actual Prelude module,
          regardless of the imports of the module being compiled).</p><p>This warning is off by default.</p></dd><dt><span class="term"><code class="option">-fwarn-incomplete-patterns</code>,
              <code class="option">-fwarn-incomplete-uni-patterns</code>:
        </span></dt><dd><a class="indexterm" name="idm317757604176"></a><a class="indexterm" name="idm317757603264"></a><a class="indexterm" name="idm317757602352"></a><a class="indexterm" name="idm317757601568"></a><p>The option <code class="option">-fwarn-incomplete-patterns</code> warns
            about places where
            a pattern-match might fail at runtime.
          The function
          <code class="function">g</code> below will fail when applied to
          non-empty lists, so the compiler will emit a warning about
          this when <code class="option">-fwarn-incomplete-patterns</code> is
          enabled.

</p><pre class="programlisting">
g [] = 2
</pre><p>

          This option isn't enabled by default because it can be
          a bit noisy, and it doesn't always indicate a bug in the
          program.  However, it's generally considered good practice
          to cover all the cases in your functions, and it is switched
          on by <code class="option">-W</code>.</p><p>The flag <code class="option">-fwarn-incomplete-uni-patterns</code> is
          similar, except that it
          applies only to lambda-expressions and pattern bindings, constructs
          that only allow a single pattern:

</p><pre class="programlisting">
h = \[] -&gt; 2
Just k = f y
</pre><p>

          </p></dd><dt><span class="term"><code class="option">-fwarn-incomplete-record-updates</code>:</span></dt><dd><a class="indexterm" name="idm317757594176"></a><a class="indexterm" name="idm317757593248"></a><a class="indexterm" name="idm317757592448"></a><p>The function
          <code class="function">f</code> below will fail when applied to
          <code class="literal">Bar</code>, so the compiler will emit a warning about
          this when <code class="option">-fwarn-incomplete-record-updates</code> is
          enabled.</p><pre class="programlisting">
data Foo = Foo { x :: Int }
         | Bar

f :: Foo -&gt; Foo
f foo = foo { x = 6 }
</pre><p>This option isn't enabled by default because it can be
          very noisy, and it often doesn't indicate a bug in the
          program.</p></dd><dt><span class="term">
          <code class="option">-fwarn-missing-fields</code>:
          <a class="indexterm" name="idm317757586960"></a>
          <a class="indexterm" name="idm317757586048"></a>
          <a class="indexterm" name="idm317757585264"></a>
        </span></dt><dd><p>This option is on by default, and warns you whenever
          the construction of a labelled field constructor isn't
          complete, missing initializers for one or more fields. While
          not an error (the missing fields are initialised with
          bottoms), it is often an indication of a programmer error.</p></dd><dt><span class="term">
          <code class="option">-fwarn-missing-import-lists</code>:
          <a class="indexterm" name="idm317757582192"></a>
          <a class="indexterm" name="idm317757581280"></a>
          <a class="indexterm" name="idm317757580496"></a>
        </span></dt><dd><p>This flag warns if you use an unqualified
            <code class="literal">import</code> declaration
            that does not explicitly list the entities brought into scope. For
            example
      </p><pre class="programlisting">
module M where
  import X( f )
  import Y
  import qualified Z
  p x = f x x
</pre><p>
          The <code class="option">-fwarn-import-lists</code> flag will warn about the import
          of <code class="literal">Y</code> but not <code class="literal">X</code>
          If module <code class="literal">Y</code> is later changed to export (say) <code class="literal">f</code>,
          then the reference to <code class="literal">f</code> in <code class="literal">M</code> will become
          ambiguous.  No warning is produced for the import of <code class="literal">Z</code>
          because extending <code class="literal">Z</code>'s exports would be unlikely to produce
          ambiguity in <code class="literal">M</code>.
        </p></dd><dt><span class="term"><code class="option">-fwarn-missing-methods</code>:</span></dt><dd><a class="indexterm" name="idm317757569104"></a><a class="indexterm" name="idm317757568192"></a><a class="indexterm" name="idm317757567408"></a><p>This option is on by default, and warns you whenever
          an instance declaration is missing one or more methods, and
          the corresponding class declaration has no default
          declaration for them.</p><p>The warning is suppressed if the method name
          begins with an underscore.  Here's an example where this is useful:
            </p><pre class="programlisting">
              class C a where
                _simpleFn :: a -&gt; String
                complexFn :: a -&gt; a -&gt; String
                complexFn x y = ... _simpleFn ...
              </pre><p>
            The idea is that: (a) users of the class will only call <code class="literal">complexFn</code>;
            never <code class="literal">_simpleFn</code>; and (b)
            instance declarations can define either <code class="literal">complexFn</code> or <code class="literal">_simpleFn</code>.
            </p><p>The MINIMAL pragma can be used to change which combination of methods will be required for instances of a particular class. See <a class="xref" href="pragmas.html#minimal-pragma" title="7.22.5. MINIMAL pragma">Section 7.22.5, &#8220;MINIMAL pragma&#8221;</a>.</p></dd><dt><span class="term"><code class="option">-fwarn-missing-signatures</code>:</span></dt><dd><a class="indexterm" name="idm317757559232"></a><a class="indexterm" name="idm317757558336"></a><p>If you would like GHC to check that every top-level
          function/value has a type signature, use the
          <code class="option">-fwarn-missing-signatures</code> option.  As part of
            the warning GHC also reports the inferred type.  The
          option is off by default.</p></dd><dt><span class="term"><code class="option">-fwarn-missing-exported-sigs</code>:</span></dt><dd><a class="indexterm" name="idm317757555056"></a><a class="indexterm" name="idm317757554144"></a><p>If you would like GHC to check that every exported top-level
          function/value has a type signature, but not check unexported values, use the
          <code class="option">-fwarn-missing-exported-sigs</code> option.  This option
          takes precedence over <code class="option">-fwarn-missing-signatures</code>.
          As part of the warning GHC also reports the inferred type.  The
          option is off by default.</p></dd><dt><span class="term"><code class="option">-fwarn-missing-local-sigs</code>:</span></dt><dd><a class="indexterm" name="idm317757550368"></a><a class="indexterm" name="idm317757549456"></a><p>If you use the
          <code class="option">-fwarn-missing-local-sigs</code> flag GHC will warn
          you about any polymorphic local bindings. As part of
            the warning GHC also reports the inferred type. The
          option is off by default.</p></dd><dt><span class="term"><code class="option">-fwarn-name-shadowing</code>:</span></dt><dd><a class="indexterm" name="idm317757546208"></a><a class="indexterm" name="idm317757545296"></a><p>This option causes a warning to be emitted whenever an
          inner-scope value has the same name as an outer-scope value,
          i.e. the inner value shadows the outer one.  This can catch
          typographical errors that turn into hard-to-find bugs, e.g.,
          in the inadvertent capture of what would be a recursive call in
          <code class="literal">f = ... let f = id in ... f ...</code>.</p><p>The warning is suppressed for names beginning with an underscore.  For example
          </p><pre class="programlisting">
             f x = do { _ignore &lt;- this; _ignore &lt;- that; return (the other) }
          </pre><p>
         </p></dd><dt><span class="term"><code class="option">-fwarn-orphans, -fwarn-auto-orphans</code>:</span></dt><dd><a class="indexterm" name="idm317757540256"></a><a class="indexterm" name="idm317757539360"></a><a class="indexterm" name="idm317757538448"></a><a class="indexterm" name="idm317757537664"></a><p>These flags cause a warning to be emitted whenever the
            module contains an "orphan" instance declaration or rewrite rule.
            An instance declaration is an orphan if it appears in a module in
            which neither the class nor the type being instanced are declared
            in the same module.  A rule is an orphan if it is a rule for a
            function declared in another module.  A module containing any
          orphans is called an orphan module.</p><p>The trouble with orphans is that GHC must pro-actively read the interface
            files for all orphan modules, just in case their instances or rules
            play a role, whether or not the module's interface would otherwise
            be of any use.  See <a class="xref" href="separate-compilation.html#orphan-modules" title="4.7.13. Orphan modules and instance declarations">Section 4.7.13, &#8220;Orphan modules and instance declarations&#8221;</a> for details.
            </p><p>The flag <code class="option">-fwarn-orphans</code> warns about user-written
            orphan rules or instances.  The flag <code class="option">-fwarn-auto-orphans</code>
            warns about automatically-generated orphan rules, notably as a result of
            specialising functions, for type classes (<code class="literal">Specialise</code>)
            or argument values (<code class="literal">-fspec-constr</code>).</p></dd><dt><span class="term">
          <code class="option">-fwarn-overlapping-patterns</code>:
          <a class="indexterm" name="idm317757530768"></a>
          <a class="indexterm" name="idm317757529856"></a>
          <a class="indexterm" name="idm317757529072"></a>
        </span></dt><dd><p>By default, the compiler will warn you if a set of
          patterns are overlapping, e.g.,</p><pre class="programlisting">
f :: String -&gt; Int
f []     = 0
f (_:xs) = 1
f "2"    = 2
</pre><p>where the last pattern match in <code class="function">f</code>
          won't ever be reached, as the second pattern overlaps
          it. More often than not, redundant patterns is a programmer
          mistake/error, so this option is enabled by default.</p></dd><dt><span class="term"><code class="option">-fwarn-tabs</code>:</span></dt><dd><a class="indexterm" name="idm317757523920"></a><a class="indexterm" name="idm317757523024"></a><p>Have the compiler warn if there are tabs in your source
          file.</p></dd><dt><span class="term"><code class="option">-fwarn-type-defaults</code>:</span></dt><dd><a class="indexterm" name="idm317757520384"></a><a class="indexterm" name="idm317757519472"></a><p>Have the compiler warn/inform you where in your source
          the Haskell defaulting mechanism for numeric types kicks
          in. This is useful information when converting code from a
          context that assumed one default into one with another,
          e.g., the &#8216;default default&#8217; for Haskell 1.4 caused the
          otherwise unconstrained value <code class="constant">1</code> to be
          given the type <code class="literal">Int</code>, whereas Haskell 98
          and later
          defaults it to <code class="literal">Integer</code>.  This may lead to
          differences in performance and behaviour, hence the
          usefulness of being non-silent about this.</p><p>This warning is off by default.</p></dd><dt><span class="term"><code class="option">-fwarn-monomorphism-restriction</code>:</span></dt><dd><a class="indexterm" name="idm317757513840"></a><a class="indexterm" name="idm317757512928"></a><p>Have the compiler warn/inform you where in your source
          the Haskell Monomorphism Restriction is applied.  If applied silently
          the MR can give rise to unexpected behaviour, so it can be helpful
          to have an explicit warning that it is being applied.</p><p>This warning is off by default.</p></dd><dt><span class="term"><code class="option">-fwarn-unticked-promoted-constructors</code>:</span></dt><dd><a class="indexterm" name="idm317757509584"></a><a class="indexterm" name="idm317757508656"></a><p>Warn if a promoted data constructor is used without a tick preceding it's name.
          </p><p>For example:
          </p><pre class="programlisting">
data Nat = Succ Nat | Zero

data Vec n s where
  Nil  :: Vec Zero a
  Cons :: a -&gt; Vec n a -&gt; Vec (Succ n) a
</pre><p> Will raise two warnings because <code class="function">Zero</code>
            and <code class="function">Succ</code> are not written as <code class="function">'Zero</code> and
            <code class="function">'Succ</code>.
            </p><p>This warning is enabled by default in <code class="literal">-Wall</code> mode.</p></dd><dt><span class="term"><code class="option">-fwarn-unused-binds</code>:</span></dt><dd><a class="indexterm" name="idm317757500608"></a><a class="indexterm" name="idm317757499696"></a><a class="indexterm" name="idm317757498912"></a><p>Report any function definitions (and local bindings)
          which are unused.  More precisely:

          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Warn if a binding brings into scope a variable that is not used,
          except if the variable's name starts with an underscore.  The "starts-with-underscore"
          condition provides a way to selectively disable the warning.
        </p><p>
          A variable is regarded as "used" if 
          </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>It is exported, or</p></li><li class="listitem"><p>It appears in the right hand side of a binding that binds at 
                           least one used variable that is used</p></li></ul></div><p>
          For example
            </p><pre class="programlisting">
module A (f) where
f = let (p,q) = rhs1 in t p  -- Warning about unused q
t = rhs3                     -- No warning: f is used, and hence so is t
g = h x                      -- Warning: g unused
h = rhs2                     -- Warning: h is only used in the right-hand side of another unused binding
_w = True                    -- No warning: _w starts with an underscore
            </pre><p>
          </p></li><li class="listitem"><p>
          Warn if a pattern binding binds no variables at all, unless it is a lone, possibly-banged, wild-card pattern.
          For example:
            </p><pre class="programlisting">
Just _ = rhs3    -- Warning: unused pattern binding
(_, _) = rhs4    -- Warning: unused pattern binding
_  = rhs3        -- No warning: lone wild-card pattern
!_ = rhs4        -- No warning: banged wild-card pattern; behaves like seq
            </pre><p>
          The motivation for allowing lone wild-card patterns is they
          are not very different from <code class="literal">_v = rhs3</code>,
          which elicits no warning; and they can be useful to add a type
          constraint, e.g. <code class="literal">_ = x::Int</code>. A lone
          banged wild-card pattern is is useful as an alternative 
          (to <code class="literal">seq</code>) way to force evaluation.
        </p></li></ul></div><p>
          </p></dd><dt><span class="term"><code class="option">-fwarn-unused-imports</code>:</span></dt><dd><a class="indexterm" name="idm317757487856"></a><a class="indexterm" name="idm317757486944"></a><a class="indexterm" name="idm317757486160"></a><p>Report any modules that are explicitly imported but
          never used.  However, the form <code class="literal">import M()</code> is
          never reported as an unused import, because it is a useful idiom
          for importing instance declarations, which are anonymous in Haskell.</p></dd><dt><span class="term"><code class="option">-fwarn-unused-matches</code>:</span></dt><dd><a class="indexterm" name="idm317757482672"></a><a class="indexterm" name="idm317757481760"></a><a class="indexterm" name="idm317757480976"></a><p>Report all unused variables which arise from pattern
          matches, including patterns consisting of a single variable.
          For instance <code class="literal">f x y = []</code> would report
          <code class="varname">x</code> and <code class="varname">y</code> as unused.  The
          warning is suppressed if the variable name begins with an underscore, thus:
            </p><pre class="programlisting">
               f _x = True
            </pre><p>
          </p></dd><dt><span class="term"><code class="option">-fwarn-unused-do-bind</code>:</span></dt><dd><a class="indexterm" name="idm317757475968"></a><a class="indexterm" name="idm317757475056"></a><a class="indexterm" name="idm317757474272"></a><p>Report expressions occurring in <code class="literal">do</code> and <code class="literal">mdo</code> blocks
          that appear to silently throw information away.
          For instance <code class="literal">do { mapM popInt xs ; return 10 }</code> would report
          the first statement in the <code class="literal">do</code> block as suspicious,
          as it has the type <code class="literal">StackM [Int]</code> and not <code class="literal">StackM ()</code>, but that
          <code class="literal">[Int]</code> value is not bound to anything.  The warning is suppressed by
          explicitly mentioning in the source code that your program is throwing something away:
            </p><pre class="programlisting">
               do { _ &lt;- mapM popInt xs ; return 10 }
            </pre><p>
          Of course, in this particular situation you can do even better:
            </p><pre class="programlisting">
               do { mapM_ popInt xs ; return 10 }
            </pre><p>
          </p></dd><dt><span class="term"><code class="option">-fwarn-context-quantification</code>:</span></dt><dd><a class="indexterm" name="idm317757448816"></a><a class="indexterm" name="idm317757447920"></a><a class="indexterm" name="idm317757447120"></a><p>Report if a variable is quantified only due to its presence
          in a context (see <a class="xref" href="other-type-extensions.html#universal-quantification" title="7.13.6. Arbitrary-rank polymorphism">Section 7.13.6, &#8220;Arbitrary-rank polymorphism
&#8221;</a>). For example,
            </p><pre class="programlisting">
              type T a = Monad m =&gt; a -&gt; f a
            </pre><p>
          It is recommended to write this polymorphic type as
            </p><pre class="programlisting">
              type T a = forall m. Monad m =&gt; a -&gt; f a
            </pre><p>
          instead.
          </p></dd><dt><span class="term"><code class="option">-fwarn-wrong-do-bind</code>:</span></dt><dd><a class="indexterm" name="idm317757442144"></a><a class="indexterm" name="idm317757441232"></a><a class="indexterm" name="idm317757440432"></a><p>Report expressions occurring in <code class="literal">do</code> and <code class="literal">mdo</code> blocks
          that appear to lack a binding.
          For instance <code class="literal">do { return (popInt 10) ; return 10 }</code> would report
          the first statement in the <code class="literal">do</code> block as suspicious,
          as it has the type <code class="literal">StackM (StackM Int)</code> (which consists of two nested applications
          of the same monad constructor), but which is not then "unpacked" by binding the result.
          The warning is suppressed by explicitly mentioning in the source code that your program is throwing something away:
            </p><pre class="programlisting">
               do { _ &lt;- return (popInt 10) ; return 10 }
            </pre><p>
          For almost all sensible programs this will indicate a bug, and you probably intended to write:
            </p><pre class="programlisting">
               do { popInt 10 ; return 10 }
            </pre><p>
          </p></dd><dt><span class="term"><code class="option">-fwarn-inline-rule-shadowing</code>:</span></dt><dd><a class="indexterm" name="idm317757431920"></a><p>Warn if a rewrite RULE might fail to fire because the function might be
                inlined before the rule has a chance to fire.  See <a class="xref" href="rewrite-rules.html#rules-inline" title="7.23.3. How rules interact with INLINE/NOINLINE pragmas">Section 7.23.3, &#8220;How rules interact with INLINE/NOINLINE pragmas&#8221;</a>.
              </p></dd></dl></div><p>If you're feeling really paranoid, the
    <code class="option">-dcore-lint</code>
    option<a class="indexterm" name="idm317757428656"></a>
    is a good choice.  It turns on heavyweight intra-pass
    sanity-checking within GHC.  (It checks GHC's sanity, not
    yours.)</p></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="separate-compilation.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="using-ghc.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="packages.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4.7. Filenames and separate compilation </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 4.9. 
Packages
 </td></tr></table></div></body></html>
