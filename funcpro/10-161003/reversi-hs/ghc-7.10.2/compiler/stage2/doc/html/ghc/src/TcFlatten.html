<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcFlatten.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcFlatten</span><span class='hs-layout'>(</span>
<a name="line-4"></a>   <span class='hs-conid'>FlattenEnv</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-conid'>FlattenMode</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkFlattenEnv</span><span class='hs-layout'>,</span>
<a name="line-5"></a>   <span class='hs-varid'>flatten</span><span class='hs-layout'>,</span> <span class='hs-varid'>flattenMany</span><span class='hs-layout'>,</span> <span class='hs-varid'>flatten_many</span><span class='hs-layout'>,</span>
<a name="line-6"></a>   <span class='hs-varid'>flattenFamApp</span><span class='hs-layout'>,</span> <span class='hs-varid'>flattenTyVarOuter</span><span class='hs-layout'>,</span>
<a name="line-7"></a>   <span class='hs-varid'>unflatten</span><span class='hs-layout'>,</span>
<a name="line-8"></a>   <span class='hs-varid'>eqCanRewrite</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqCanRewriteFR</span><span class='hs-layout'>,</span> <span class='hs-varid'>canRewriteOrSame</span><span class='hs-layout'>,</span>
<a name="line-9"></a>   <span class='hs-conid'>CtFlavourRole</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctEvFlavourRole</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctFlavourRole</span>
<a name="line-10"></a> <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnTypes</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TypeRep</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Kind</span><span class='hs-layout'>(</span> <span class='hs-varid'>isSubKind</span> <span class='hs-layout'>)</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Coercion</span>  <span class='hs-layout'>(</span> <span class='hs-varid'>tyConRolesX</span> <span class='hs-layout'>)</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarEnv</span>
<a name="line-24"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>NameEnv</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TcS</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span><span class='hs-layout'>(</span> <span class='hs-conid'>DynFlags</span> <span class='hs-layout'>)</span>
<a name="line-29"></a>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span><span class='hs-layout'>(</span> <span class='hs-varid'>when</span><span class='hs-layout'>,</span> <span class='hs-varid'>liftM</span> <span class='hs-layout'>)</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>MonadUtils</span> <span class='hs-layout'>(</span> <span class='hs-varid'>zipWithAndUnzipM</span> <span class='hs-layout'>)</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>GHC</span><span class='hs-varop'>.</span><span class='hs-conid'>Exts</span> <span class='hs-layout'>(</span> <span class='hs-varid'>inline</span> <span class='hs-layout'>)</span>
<a name="line-36"></a>
<a name="line-37"></a><span class='hs-comment'>{-
<a name="line-38"></a>Note [The flattening story]
<a name="line-39"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-40"></a>* A CFunEqCan is either of form
<a name="line-41"></a>     [G] &lt;F xis&gt; : F xis ~ fsk   -- fsk is a FlatSkol
<a name="line-42"></a>     [W]       x : F xis ~ fmv   -- fmv is a unification variable,
<a name="line-43"></a>                                 -- but untouchable,
<a name="line-44"></a>                                 -- with MetaInfo = FlatMetaTv
<a name="line-45"></a>  where
<a name="line-46"></a>     x is the witness variable
<a name="line-47"></a>     fsk/fmv is a flatten skolem
<a name="line-48"></a>     xis are function-free
<a name="line-49"></a>  CFunEqCans are always [Wanted], or [Given], never [Derived]
<a name="line-50"></a>
<a name="line-51"></a>  fmv untouchable just means that in a CTyVarEq, say,
<a name="line-52"></a>       fmv ~ Int
<a name="line-53"></a>  we do NOT unify fmv.
<a name="line-54"></a>
<a name="line-55"></a>* KEY INSIGHTS:
<a name="line-56"></a>
<a name="line-57"></a>   - A given flatten-skolem, fsk, is known a-priori to be equal to
<a name="line-58"></a>     F xis (the LHS), with &lt;F xis&gt; evidence
<a name="line-59"></a>
<a name="line-60"></a>   - A unification flatten-skolem, fmv, stands for the as-yet-unknown
<a name="line-61"></a>     type to which (F xis) will eventually reduce
<a name="line-62"></a>
<a name="line-63"></a>* Inert set invariant: if F xis1 ~ fsk1, F xis2 ~ fsk2
<a name="line-64"></a>                       then xis1 /= xis2
<a name="line-65"></a>  i.e. at most one CFunEqCan with a particular LHS
<a name="line-66"></a>
<a name="line-67"></a>* Each canonical CFunEqCan x : F xis ~ fsk/fmv has its own
<a name="line-68"></a>  distinct evidence variable x and flatten-skolem fsk/fmv.
<a name="line-69"></a>  Why? We make a fresh fsk/fmv when the constraint is born;
<a name="line-70"></a>  and we never rewrite the RHS of a CFunEqCan.
<a name="line-71"></a>
<a name="line-72"></a>* Function applications can occur in the RHS of a CTyEqCan.  No reason
<a name="line-73"></a>  not allow this, and it reduces the amount of flattening that must occur.
<a name="line-74"></a>
<a name="line-75"></a>* Flattening a type (F xis):
<a name="line-76"></a>    - If we are flattening in a Wanted/Derived constraint
<a name="line-77"></a>      then create new [W] x : F xis ~ fmv
<a name="line-78"></a>      else create new [G] x : F xis ~ fsk
<a name="line-79"></a>      with fresh evidence variable x and flatten-skolem fsk/fmv
<a name="line-80"></a>
<a name="line-81"></a>    - Add it to the work list
<a name="line-82"></a>
<a name="line-83"></a>    - Replace (F xis) with fsk/fmv in the type you are flattening
<a name="line-84"></a>
<a name="line-85"></a>    - You can also add the CFunEqCan to the "flat cache", which
<a name="line-86"></a>      simply keeps track of all the function applications you
<a name="line-87"></a>      have flattened.
<a name="line-88"></a>
<a name="line-89"></a>    - If (F xis) is in the cache already, just
<a name="line-90"></a>      use its fsk/fmv and evidence x, and emit nothing.
<a name="line-91"></a>
<a name="line-92"></a>    - No need to substitute in the flat-cache. It's not the end
<a name="line-93"></a>      of the world if we start with, say (F alpha ~ fmv1) and
<a name="line-94"></a>      (F Int ~ fmv2) and then find alpha := Int.  Athat will
<a name="line-95"></a>      simply give rise to fmv1 := fmv2 via [Interacting rule] below
<a name="line-96"></a>
<a name="line-97"></a>* Canonicalising a CFunEqCan [G/W] x : F xis ~ fsk/fmv
<a name="line-98"></a>    - Flatten xis (to substitute any tyvars; there are already no functions)
<a name="line-99"></a>                  cos :: xis ~ flat_xis
<a name="line-100"></a>    - New wanted  x2 :: F flat_xis ~ fsk/fmv
<a name="line-101"></a>    - Add new wanted to flat cache
<a name="line-102"></a>    - Discharge x = F cos ; x2
<a name="line-103"></a>
<a name="line-104"></a>* Unification flatten-skolems, fmv, ONLY get unified when either
<a name="line-105"></a>    a) The CFunEqCan takes a step, using an axiom
<a name="line-106"></a>    b) During un-flattening
<a name="line-107"></a>  They are never unified in any other form of equality.
<a name="line-108"></a>  For example [W] ffmv ~ Int  is stuck; it does not unify with fmv.
<a name="line-109"></a>
<a name="line-110"></a>* We *never* substitute in the RHS (i.e. the fsk/fmv) of a CFunEqCan.
<a name="line-111"></a>  That would destroy the invariant about the shape of a CFunEqCan,
<a name="line-112"></a>  and it would risk wanted/wanted interactions. The only way we
<a name="line-113"></a>  learn information about fsk is when the CFunEqCan takes a step.
<a name="line-114"></a>
<a name="line-115"></a>  However we *do* substitute in the LHS of a CFunEqCan (else it
<a name="line-116"></a>  would never get to fire!)
<a name="line-117"></a>
<a name="line-118"></a>* [Interacting rule]
<a name="line-119"></a>    (inert)     [W] x1 : F tys ~ fmv1
<a name="line-120"></a>    (work item) [W] x2 : F tys ~ fmv2
<a name="line-121"></a>  Just solve one from the other:
<a name="line-122"></a>    x2 := x1
<a name="line-123"></a>    fmv2 := fmv1
<a name="line-124"></a>  This just unites the two fsks into one.
<a name="line-125"></a>  Always solve given from wanted if poss.
<a name="line-126"></a>
<a name="line-127"></a>* [Firing rule: wanteds]
<a name="line-128"></a>    (work item) [W] x : F tys ~ fmv
<a name="line-129"></a>    instantiate axiom: ax_co : F tys ~ rhs
<a name="line-130"></a>
<a name="line-131"></a>   Dischard fmv:
<a name="line-132"></a>      fmv := alpha
<a name="line-133"></a>      x := ax_co ; sym x2
<a name="line-134"></a>      [W] x2 : alpha ~ rhs  (Non-canonical)
<a name="line-135"></a>   discharging the work item. This is the way that fmv's get
<a name="line-136"></a>   unified; even though they are "untouchable".
<a name="line-137"></a>
<a name="line-138"></a>   NB: this deals with the case where fmv appears in xi, which can
<a name="line-139"></a>   happen; it just happens through the non-canonical stuff
<a name="line-140"></a>
<a name="line-141"></a>   Possible short cut (shortCutReduction) if rhs = G rhs_tys,
<a name="line-142"></a>   where G is a type function.  Then
<a name="line-143"></a>      - Flatten rhs_tys (cos : rhs_tys ~ rhs_xis)
<a name="line-144"></a>      - Add G rhs_xis ~ fmv to flat cache
<a name="line-145"></a>      - New wanted [W] x2 : G rhs_xis ~ fmv
<a name="line-146"></a>      - Discharge x := co ; G cos ; x2
<a name="line-147"></a>
<a name="line-148"></a>* [Firing rule: givens]
<a name="line-149"></a>    (work item) [G] g : F tys ~ fsk
<a name="line-150"></a>    instantiate axiom: co : F tys ~ rhs
<a name="line-151"></a>
<a name="line-152"></a>   Now add non-canonical (since rhs is not flat)
<a name="line-153"></a>      [G] (sym g ; co) : fsk ~ rhs
<a name="line-154"></a>
<a name="line-155"></a>   Short cut (shortCutReduction) for when rhs = G rhs_tys and G is a type function
<a name="line-156"></a>      [G] (co ; g) : G tys ~ fsk
<a name="line-157"></a>   But need to flatten tys:  flat_cos : tys ~ flat_tys
<a name="line-158"></a>      [G] (sym (G flat_cos) ; co ; g) : G flat_tys ~ fsk
<a name="line-159"></a>
<a name="line-160"></a>
<a name="line-161"></a>Why given-fsks, alone, doesn't work
<a name="line-162"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-163"></a>Could we get away with only flatten meta-tyvars, with no flatten-skolems? No.
<a name="line-164"></a>
<a name="line-165"></a>  [W] w : alpha ~ [F alpha Int]
<a name="line-166"></a>
<a name="line-167"></a>---&gt; flatten
<a name="line-168"></a>  w = ...w'...
<a name="line-169"></a>  [W] w' : alpha ~ [fsk]
<a name="line-170"></a>  [G] &lt;F alpha Int&gt; : F alpha Int ~ fsk
<a name="line-171"></a>
<a name="line-172"></a>--&gt; unify (no occurs check)
<a name="line-173"></a>  alpha := [fsk]
<a name="line-174"></a>
<a name="line-175"></a>But since fsk = F alpha Int, this is really an occurs check error.  If
<a name="line-176"></a>that is all we know about alpha, we will succeed in constraint
<a name="line-177"></a>solving, producing a program with an infinite type.
<a name="line-178"></a>
<a name="line-179"></a>Even if we did finally get (g : fsk ~ Boo)l by solving (F alpha Int ~ fsk)
<a name="line-180"></a>using axiom, zonking would not see it, so (x::alpha) sitting in the
<a name="line-181"></a>tree will get zonked to an infinite type.  (Zonking always only does
<a name="line-182"></a>refl stuff.)
<a name="line-183"></a>
<a name="line-184"></a>Why flatten-meta-vars, alone doesn't work
<a name="line-185"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-186"></a>Look at Simple13, with unification-fmvs only
<a name="line-187"></a>
<a name="line-188"></a>  [G] g : a ~ [F a]
<a name="line-189"></a>
<a name="line-190"></a>---&gt; Flatten given
<a name="line-191"></a>  g' = g;[x]
<a name="line-192"></a>  [G] g'  : a ~ [fmv]
<a name="line-193"></a>  [W] x : F a ~ fmv
<a name="line-194"></a>
<a name="line-195"></a>--&gt; subst a in x
<a name="line-196"></a>       x = F g' ; x2
<a name="line-197"></a>   [W] x2 : F [fmv] ~ fmv
<a name="line-198"></a>
<a name="line-199"></a>And now we have an evidence cycle between g' and x!
<a name="line-200"></a>
<a name="line-201"></a>If we used a given instead (ie current story)
<a name="line-202"></a>
<a name="line-203"></a>  [G] g : a ~ [F a]
<a name="line-204"></a>
<a name="line-205"></a>---&gt; Flatten given
<a name="line-206"></a>  g' = g;[x]
<a name="line-207"></a>  [G] g'  : a ~ [fsk]
<a name="line-208"></a>  [G] &lt;F a&gt; : F a ~ fsk
<a name="line-209"></a>
<a name="line-210"></a>---&gt; Substitute for a
<a name="line-211"></a>  [G] g'  : a ~ [fsk]
<a name="line-212"></a>  [G] F (sym g'); &lt;F a&gt; : F [fsk] ~ fsk
<a name="line-213"></a>
<a name="line-214"></a>
<a name="line-215"></a>Why is it right to treat fmv's differently to ordinary unification vars?
<a name="line-216"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-217"></a>  f :: forall a. a -&gt; a -&gt; Bool
<a name="line-218"></a>  g :: F Int -&gt; F Int -&gt; Bool
<a name="line-219"></a>
<a name="line-220"></a>Consider
<a name="line-221"></a>  f (x:Int) (y:Bool)
<a name="line-222"></a>This gives alpha~Int, alpha~Bool.  There is an inconsistency,
<a name="line-223"></a>but really only one error.  SherLoc may tell you which location
<a name="line-224"></a>is most likely, based on other occurrences of alpha.
<a name="line-225"></a>
<a name="line-226"></a>Consider
<a name="line-227"></a>  g (x:Int) (y:Bool)
<a name="line-228"></a>Here we get (F Int ~ Int, F Int ~ Bool), which flattens to
<a name="line-229"></a>  (fmv ~ Int, fmv ~ Bool)
<a name="line-230"></a>But there are really TWO separate errors.  We must not complain
<a name="line-231"></a>about Int~Bool.  Moreover these two errors could arise in entirely
<a name="line-232"></a>unrelated parts of the code.  (In the alpha case, there must be
<a name="line-233"></a>*some* connection (eg v:alpha in common envt).)
<a name="line-234"></a>
<a name="line-235"></a>Note [Orient equalities with flatten-meta-vars on the left]
<a name="line-236"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-237"></a>This example comes from IndTypesPerfMerge
<a name="line-238"></a>
<a name="line-239"></a>From the ambiguity check for
<a name="line-240"></a>  f :: (F a ~ a) =&gt; a
<a name="line-241"></a>we get:
<a name="line-242"></a>      [G] F a ~ a
<a name="line-243"></a>      [W] F alpha ~ alpha, alpha ~ a
<a name="line-244"></a>
<a name="line-245"></a>    From Givens we get
<a name="line-246"></a>      [G] F a ~ fsk, fsk ~ a
<a name="line-247"></a>
<a name="line-248"></a>    Now if we flatten we get
<a name="line-249"></a>      [W] alpha ~ fmv, F alpha ~ fmv, alpha ~ a
<a name="line-250"></a>
<a name="line-251"></a>    Now, processing the first one first, choosing alpha := fmv
<a name="line-252"></a>      [W] F fmv ~ fmv, fmv ~ a
<a name="line-253"></a>
<a name="line-254"></a>    And now we are stuck.  We must either *unify* fmv := a, or
<a name="line-255"></a>    use the fmv ~ a to rewrite F fmv ~ fmv, so we can make it
<a name="line-256"></a>    meet up with the given F a ~ blah.
<a name="line-257"></a>
<a name="line-258"></a>Solution: always put fmvs on the left, so we get
<a name="line-259"></a>      [W] fmv ~ alpha, F alpha ~ fmv, alpha ~ a
<a name="line-260"></a>  The point is that fmvs are very uninformative, so doing alpha := fmv
<a name="line-261"></a>  is a bad idea.  We want to use other constraints on alpha first.
<a name="line-262"></a>
<a name="line-263"></a>
<a name="line-264"></a>Note [Derived constraints from wanted CTyEqCans]
<a name="line-265"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-266"></a>Is this type ambiguous:  (Foo e ~ Maybe e) =&gt; Foo e
<a name="line-267"></a> (indexed-types/should_fail/T4093a)
<a name="line-268"></a>
<a name="line-269"></a> [G] Foo e ~ Maybe e
<a name="line-270"></a> [W] Foo e ~ Foo ee      -- ee is a unification variable
<a name="line-271"></a> [W] Foo ee ~ Maybe ee)
<a name="line-272"></a>---
<a name="line-273"></a> [G] Foo e ~ fsk
<a name="line-274"></a> [G] fsk ~ Maybe e
<a name="line-275"></a>
<a name="line-276"></a> [W] Foo e ~ fmv1
<a name="line-277"></a> [W] Foo ee ~ fmv2
<a name="line-278"></a> [W] fmv1 ~ fmv2
<a name="line-279"></a> [W] fmv2 ~ Maybe ee
<a name="line-280"></a>
<a name="line-281"></a>---&gt;   fmv1 := fsk  by matching LHSs
<a name="line-282"></a> [W] Foo ee ~ fmv2
<a name="line-283"></a> [W] fsk ~ fmv2
<a name="line-284"></a> [W] fmv2 ~ Maybe ee
<a name="line-285"></a>
<a name="line-286"></a>---&gt;
<a name="line-287"></a> [W] Foo ee ~ fmv2
<a name="line-288"></a> [W] fmv2 ~ Maybe e
<a name="line-289"></a> [W] fmv2 ~ Maybe ee
<a name="line-290"></a>
<a name="line-291"></a>Now maybe we shuld get [D] e ~ ee, and then we'd solve it entirely.
<a name="line-292"></a>But if in a smilar situation we got [D] Int ~ Bool we'd be back
<a name="line-293"></a>to complaining about wanted/wanted interactions.  Maybe this arises
<a name="line-294"></a>also for fundeps?
<a name="line-295"></a>
<a name="line-296"></a>Here's another example:
<a name="line-297"></a>  f :: [a] -&gt; [b] -&gt; blah
<a name="line-298"></a>  f (e1 :: F Int) (e2 :: F Int)
<a name="line-299"></a>
<a name="line-300"></a>  we get
<a name="line-301"></a>     F Int ~ fmv
<a name="line-302"></a>     fmv ~ [alpha]
<a name="line-303"></a>     fmv ~ [beta]
<a name="line-304"></a>
<a name="line-305"></a>  We want: alpha := beta (which might unlock something else).  If we
<a name="line-306"></a>  generated [D] [alpha] ~ [beta] we'd be good here.
<a name="line-307"></a>
<a name="line-308"></a>Current story: we don't generate these derived constraints.  We could, but
<a name="line-309"></a>we'd want to make them very weak, so we didn't get the Int~Bool complaint.
<a name="line-310"></a>
<a name="line-311"></a>
<a name="line-312"></a>************************************************************************
<a name="line-313"></a>*                                                                      *
<a name="line-314"></a>*                  Other notes (Oct 14)
<a name="line-315"></a>      I have not revisted these, but I didn't want to discard them
<a name="line-316"></a>*                                                                      *
<a name="line-317"></a>************************************************************************
<a name="line-318"></a>
<a name="line-319"></a>
<a name="line-320"></a>Try: rewrite wanted with wanted only for fmvs (not all meta-tyvars)
<a name="line-321"></a>
<a name="line-322"></a>But:   fmv ~ alpha[0]
<a name="line-323"></a>       alpha[0] ~ fmv’
<a name="line-324"></a>Now we don’t see that fmv ~ fmv’, which is a problem for injectivity detection.
<a name="line-325"></a>
<a name="line-326"></a>Conclusion: rewrite wanteds with wanted for all untouchables.
<a name="line-327"></a>
<a name="line-328"></a>skol ~ untch, must re-orieint to untch ~ skol, so that we can use it to rewrite.
<a name="line-329"></a>
<a name="line-330"></a>
<a name="line-331"></a>
<a name="line-332"></a>************************************************************************
<a name="line-333"></a>*                                                                      *
<a name="line-334"></a>*                  Examples
<a name="line-335"></a>     Here is a long series of examples I had to work through
<a name="line-336"></a>*                                                                      *
<a name="line-337"></a>************************************************************************
<a name="line-338"></a>
<a name="line-339"></a>Simple20
<a name="line-340"></a>~~~~~~~~
<a name="line-341"></a>axiom F [a] = [F a]
<a name="line-342"></a>
<a name="line-343"></a> [G] F [a] ~ a
<a name="line-344"></a>--&gt;
<a name="line-345"></a> [G] fsk ~ a
<a name="line-346"></a> [G] [F a] ~ fsk  (nc)
<a name="line-347"></a>--&gt;
<a name="line-348"></a> [G] F a ~ fsk2
<a name="line-349"></a> [G] fsk ~ [fsk2]
<a name="line-350"></a> [G] fsk ~ a
<a name="line-351"></a>--&gt;
<a name="line-352"></a> [G] F a ~ fsk2
<a name="line-353"></a> [G] a ~ [fsk2]
<a name="line-354"></a> [G] fsk ~ a
<a name="line-355"></a>
<a name="line-356"></a>
<a name="line-357"></a>-----------------------------------
<a name="line-358"></a>
<a name="line-359"></a>----------------------------------------
<a name="line-360"></a>indexed-types/should_compile/T44984
<a name="line-361"></a>
<a name="line-362"></a>  [W] H (F Bool) ~ H alpha
<a name="line-363"></a>  [W] alpha ~ F Bool
<a name="line-364"></a>--&gt;
<a name="line-365"></a>  F Bool  ~ fmv0
<a name="line-366"></a>  H fmv0  ~ fmv1
<a name="line-367"></a>  H alpha ~ fmv2
<a name="line-368"></a>
<a name="line-369"></a>  fmv1 ~ fmv2
<a name="line-370"></a>  fmv0 ~ alpha
<a name="line-371"></a>
<a name="line-372"></a>flatten
<a name="line-373"></a>~~~~~~~
<a name="line-374"></a>  fmv0  := F Bool
<a name="line-375"></a>  fmv1  := H (F Bool)
<a name="line-376"></a>  fmv2  := H alpha
<a name="line-377"></a>  alpha := F Bool
<a name="line-378"></a>plus
<a name="line-379"></a>  fmv1 ~ fmv2
<a name="line-380"></a>
<a name="line-381"></a>But these two are equal under the above assumptions.
<a name="line-382"></a>Solve by Refl.
<a name="line-383"></a>
<a name="line-384"></a>
<a name="line-385"></a>--- under plan B, namely solve fmv1:=fmv2 eagerly ---
<a name="line-386"></a>  [W] H (F Bool) ~ H alpha
<a name="line-387"></a>  [W] alpha ~ F Bool
<a name="line-388"></a>--&gt;
<a name="line-389"></a>  F Bool  ~ fmv0
<a name="line-390"></a>  H fmv0  ~ fmv1
<a name="line-391"></a>  H alpha ~ fmv2
<a name="line-392"></a>
<a name="line-393"></a>  fmv1 ~ fmv2
<a name="line-394"></a>  fmv0 ~ alpha
<a name="line-395"></a>--&gt;
<a name="line-396"></a>  F Bool  ~ fmv0
<a name="line-397"></a>  H fmv0  ~ fmv1
<a name="line-398"></a>  H alpha ~ fmv2    fmv2 := fmv1
<a name="line-399"></a>
<a name="line-400"></a>  fmv0 ~ alpha
<a name="line-401"></a>
<a name="line-402"></a>flatten
<a name="line-403"></a>  fmv0 := F Bool
<a name="line-404"></a>  fmv1 := H fmv0 = H (F Bool)
<a name="line-405"></a>  retain   H alpha ~ fmv2
<a name="line-406"></a>    because fmv2 has been filled
<a name="line-407"></a>  alpha := F Bool
<a name="line-408"></a>
<a name="line-409"></a>
<a name="line-410"></a>----------------------------
<a name="line-411"></a>indexed-types/should_failt/T4179
<a name="line-412"></a>
<a name="line-413"></a>after solving
<a name="line-414"></a>  [W] fmv_1 ~ fmv_2
<a name="line-415"></a>  [W] A3 (FCon x)           ~ fmv_1    (CFunEqCan)
<a name="line-416"></a>  [W] A3 (x (aoa -&gt; fmv_2)) ~ fmv_2    (CFunEqCan)
<a name="line-417"></a>
<a name="line-418"></a>----------------------------------------
<a name="line-419"></a>indexed-types/should_fail/T7729a
<a name="line-420"></a>
<a name="line-421"></a>a)  [W]   BasePrimMonad (Rand m) ~ m1
<a name="line-422"></a>b)  [W]   tt m1 ~ BasePrimMonad (Rand m)
<a name="line-423"></a>
<a name="line-424"></a>---&gt;  process (b) first
<a name="line-425"></a>    BasePrimMonad (Ramd m) ~ fmv_atH
<a name="line-426"></a>    fmv_atH ~ tt m1
<a name="line-427"></a>
<a name="line-428"></a>---&gt;  now process (a)
<a name="line-429"></a>    m1 ~ s_atH ~ tt m1    -- An obscure occurs check
<a name="line-430"></a>
<a name="line-431"></a>
<a name="line-432"></a>----------------------------------------
<a name="line-433"></a>typecheck/TcTypeNatSimple
<a name="line-434"></a>
<a name="line-435"></a>Original constraint
<a name="line-436"></a>  [W] x + y ~ x + alpha  (non-canonical)
<a name="line-437"></a>==&gt;
<a name="line-438"></a>  [W] x + y     ~ fmv1   (CFunEqCan)
<a name="line-439"></a>  [W] x + alpha ~ fmv2   (CFuneqCan)
<a name="line-440"></a>  [W] fmv1 ~ fmv2        (CTyEqCan)
<a name="line-441"></a>
<a name="line-442"></a>(sigh)
<a name="line-443"></a>
<a name="line-444"></a>----------------------------------------
<a name="line-445"></a>indexed-types/should_fail/GADTwrong1
<a name="line-446"></a>
<a name="line-447"></a>  [G] Const a ~ ()
<a name="line-448"></a>==&gt; flatten
<a name="line-449"></a>  [G] fsk ~ ()
<a name="line-450"></a>  work item: Const a ~ fsk
<a name="line-451"></a>==&gt; fire top rule
<a name="line-452"></a>  [G] fsk ~ ()
<a name="line-453"></a>  work item fsk ~ ()
<a name="line-454"></a>
<a name="line-455"></a>Surely the work item should rewrite to () ~ ()?  Well, maybe not;
<a name="line-456"></a>it'a very special case.  More generally, our givens look like
<a name="line-457"></a>F a ~ Int, where (F a) is not reducible.
<a name="line-458"></a>
<a name="line-459"></a>
<a name="line-460"></a>----------------------------------------
<a name="line-461"></a>indexed_types/should_fail/T8227:
<a name="line-462"></a>
<a name="line-463"></a>Why using a different can-rewrite rule in CFunEqCan heads
<a name="line-464"></a>does not work.
<a name="line-465"></a>
<a name="line-466"></a>Assuming NOT rewriting wanteds with wanteds
<a name="line-467"></a>
<a name="line-468"></a>   Inert: [W] fsk_aBh ~ fmv_aBk -&gt; fmv_aBk
<a name="line-469"></a>          [W] fmv_aBk ~ fsk_aBh
<a name="line-470"></a>
<a name="line-471"></a>          [G] Scalar fsk_aBg ~ fsk_aBh
<a name="line-472"></a>          [G] V a ~ f_aBg
<a name="line-473"></a>
<a name="line-474"></a>   Worklist includes  [W] Scalar fmv_aBi ~ fmv_aBk
<a name="line-475"></a>   fmv_aBi, fmv_aBk are flatten unificaiton variables
<a name="line-476"></a>
<a name="line-477"></a>   Work item: [W] V fsk_aBh ~ fmv_aBi
<a name="line-478"></a>
<a name="line-479"></a>Note that the inert wanteds are cyclic, because we do not rewrite
<a name="line-480"></a>wanteds with wanteds.
<a name="line-481"></a>
<a name="line-482"></a>
<a name="line-483"></a>Then we go into a loop when normalise the work-item, because we
<a name="line-484"></a>use rewriteOrSame on the argument of V.
<a name="line-485"></a>
<a name="line-486"></a>Conclusion: Don't make canRewrite context specific; instead use
<a name="line-487"></a>[W] a ~ ty to rewrite a wanted iff 'a' is a unification variable.
<a name="line-488"></a>
<a name="line-489"></a>
<a name="line-490"></a>----------------------------------------
<a name="line-491"></a>
<a name="line-492"></a>Here is a somewhat similar case:
<a name="line-493"></a>
<a name="line-494"></a>   type family G a :: *
<a name="line-495"></a>
<a name="line-496"></a>   blah :: (G a ~ Bool, Eq (G a)) =&gt; a -&gt; a
<a name="line-497"></a>   blah = error "urk"
<a name="line-498"></a>
<a name="line-499"></a>   foo x = blah x
<a name="line-500"></a>
<a name="line-501"></a>For foo we get
<a name="line-502"></a>   [W] Eq (G a), G a ~ Bool
<a name="line-503"></a>Flattening
<a name="line-504"></a>   [W] G a ~ fmv, Eq fmv, fmv ~ Bool
<a name="line-505"></a>We can't simplify away the Eq Bool unless we substitute for fmv.
<a name="line-506"></a>Maybe that doesn't matter: we would still be left with unsolved
<a name="line-507"></a>G a ~ Bool.
<a name="line-508"></a>
<a name="line-509"></a>--------------------------
<a name="line-510"></a>Trac #9318 has a very simple program leading to
<a name="line-511"></a>
<a name="line-512"></a>  [W] F Int ~ Int
<a name="line-513"></a>  [W] F Int ~ Bool
<a name="line-514"></a>
<a name="line-515"></a>We don't want to get "Error Int~Bool".  But if fmv's can rewrite
<a name="line-516"></a>wanteds, we will
<a name="line-517"></a>
<a name="line-518"></a>  [W] fmv ~ Int
<a name="line-519"></a>  [W] fmv ~ Bool
<a name="line-520"></a>---&gt;
<a name="line-521"></a>  [W] Int ~ Bool
<a name="line-522"></a>
<a name="line-523"></a>
<a name="line-524"></a>************************************************************************
<a name="line-525"></a>*                                                                      *
<a name="line-526"></a>*           The main flattening functions
<a name="line-527"></a>*                                                                      *
<a name="line-528"></a>************************************************************************
<a name="line-529"></a>
<a name="line-530"></a>Note [Flattening]
<a name="line-531"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-532"></a>  flatten ty  ==&gt;   (xi, cc)
<a name="line-533"></a>    where
<a name="line-534"></a>      xi has no type functions, unless they appear under ForAlls
<a name="line-535"></a>
<a name="line-536"></a>      cc = Auxiliary given (equality) constraints constraining
<a name="line-537"></a>           the fresh type variables in xi.  Evidence for these
<a name="line-538"></a>           is always the identity coercion, because internally the
<a name="line-539"></a>           fresh flattening skolem variables are actually identified
<a name="line-540"></a>           with the types they have been generated to stand in for.
<a name="line-541"></a>
<a name="line-542"></a>Note that it is flatten's job to flatten *every type function it sees*.
<a name="line-543"></a>flatten is only called on *arguments* to type functions, by canEqGiven.
<a name="line-544"></a>
<a name="line-545"></a>Recall that in comments we use alpha[flat = ty] to represent a
<a name="line-546"></a>flattening skolem variable alpha which has been generated to stand in
<a name="line-547"></a>for ty.
<a name="line-548"></a>
<a name="line-549"></a>----- Example of flattening a constraint: ------
<a name="line-550"></a>  flatten (List (F (G Int)))  ==&gt;  (xi, cc)
<a name="line-551"></a>    where
<a name="line-552"></a>      xi  = List alpha
<a name="line-553"></a>      cc  = { G Int ~ beta[flat = G Int],
<a name="line-554"></a>              F beta ~ alpha[flat = F beta] }
<a name="line-555"></a>Here
<a name="line-556"></a>  * alpha and beta are 'flattening skolem variables'.
<a name="line-557"></a>  * All the constraints in cc are 'given', and all their coercion terms
<a name="line-558"></a>    are the identity.
<a name="line-559"></a>
<a name="line-560"></a>NB: Flattening Skolems only occur in canonical constraints, which
<a name="line-561"></a>are never zonked, so we don't need to worry about zonking doing
<a name="line-562"></a>accidental unflattening.
<a name="line-563"></a>
<a name="line-564"></a>Note that we prefer to leave type synonyms unexpanded when possible,
<a name="line-565"></a>so when the flattener encounters one, it first asks whether its
<a name="line-566"></a>transitive expansion contains any type function applications.  If so,
<a name="line-567"></a>it expands the synonym and proceeds; if not, it simply returns the
<a name="line-568"></a>unexpanded synonym.
<a name="line-569"></a>
<a name="line-570"></a>Note [Flattener EqRels]
<a name="line-571"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-572"></a>When flattening, we need to know which equality relation -- nominal
<a name="line-573"></a>or representation -- we should be respecting. The only difference is
<a name="line-574"></a>that we rewrite variables by representational equalities when fe_eq_rel
<a name="line-575"></a>is ReprEq.
<a name="line-576"></a>
<a name="line-577"></a>-}</span>
<a name="line-578"></a>
<a name="line-579"></a><a name="FlattenEnv"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FlattenEnv</span>
<a name="line-580"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span>    <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span>
<a name="line-581"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_loc</span>     <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtLoc</span>
<a name="line-582"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtFlavour</span>
<a name="line-583"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>fe_eq_rel</span>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EqRel</span> <span class='hs-layout'>}</span>   <span class='hs-comment'>-- See Note [Flattener EqRels]</span>
<a name="line-584"></a>
<a name="line-585"></a><a name="FlattenMode"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>FlattenMode</span>  <span class='hs-comment'>-- Postcondition for all three: inert wrt the type substitution</span>
<a name="line-586"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FM_FlattenAll</span>          <span class='hs-comment'>-- Postcondition: function-free</span>
<a name="line-587"></a>
<a name="line-588"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FM_Avoid</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-conid'>Bool</span>  <span class='hs-comment'>-- See Note [Lazy flattening]</span>
<a name="line-589"></a>                           <span class='hs-comment'>-- Postcondition:</span>
<a name="line-590"></a>                           <span class='hs-comment'>--  * tyvar is only mentioned in result under a rigid path</span>
<a name="line-591"></a>                           <span class='hs-comment'>--    e.g.   [a] is ok, but F a won't happen</span>
<a name="line-592"></a>                           <span class='hs-comment'>--  * If flat_top is True, top level is not a function application</span>
<a name="line-593"></a>                           <span class='hs-comment'>--   (but under type constructors is ok e.g. [F a])</span>
<a name="line-594"></a>
<a name="line-595"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>FM_SubstOnly</span>           <span class='hs-comment'>-- See Note [Flattening under a forall]</span>
<a name="line-596"></a>
<a name="line-597"></a><a name="mkFlattenEnv"></a><span class='hs-definition'>mkFlattenEnv</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlattenEnv</span>
<a name="line-598"></a><span class='hs-definition'>mkFlattenEnv</span> <span class='hs-varid'>fm</span> <span class='hs-varid'>ctev</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>FE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fm</span>
<a name="line-599"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>fe_loc</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvLoc</span> <span class='hs-varid'>ctev</span>
<a name="line-600"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvFlavour</span> <span class='hs-varid'>ctev</span>
<a name="line-601"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>fe_eq_rel</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvEqRel</span> <span class='hs-varid'>ctev</span> <span class='hs-layout'>}</span>
<a name="line-602"></a>
<a name="line-603"></a><a name="feRole"></a><span class='hs-definition'>feRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Role</span>
<a name="line-604"></a><span class='hs-definition'>feRole</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varop'>.</span> <span class='hs-varid'>fe_eq_rel</span>
<a name="line-605"></a>
<a name="line-606"></a><span class='hs-comment'>{-
<a name="line-607"></a>Note [Lazy flattening]
<a name="line-608"></a>~~~~~~~~~~~~~~~~~~~~~~
<a name="line-609"></a>The idea of FM_Avoid mode is to flatten less aggressively.  If we have
<a name="line-610"></a>       a ~ [F Int]
<a name="line-611"></a>there seems to be no great merit in lifting out (F Int).  But if it was
<a name="line-612"></a>       a ~ [G a Int]
<a name="line-613"></a>then we *do* want to lift it out, in case (G a Int) reduces to Bool, say,
<a name="line-614"></a>which gets rid of the occurs-check problem.  (For the flat_top Bool, see
<a name="line-615"></a>comments above and at call sites.)
<a name="line-616"></a>
<a name="line-617"></a>HOWEVER, the lazy flattening actually seems to make type inference go
<a name="line-618"></a>*slower*, not faster.  perf/compiler/T3064 is a case in point; it gets
<a name="line-619"></a>*dramatically* worse with FM_Avoid.  I think it may be because
<a name="line-620"></a>floating the types out means we normalise them, and that often makes
<a name="line-621"></a>them smaller and perhaps allows more re-use of previously solved
<a name="line-622"></a>goals.  But to be honest I'm not absolutely certain, so I am leaving
<a name="line-623"></a>FM_Avoid in the code base.  What I'm removing is the unique place
<a name="line-624"></a>where it is *used*, namely in TcCanonical.canEqTyVar.
<a name="line-625"></a>
<a name="line-626"></a>See also Note [Conservative unification check] in TcUnify, which gives
<a name="line-627"></a>other examples where lazy flattening caused problems.
<a name="line-628"></a>
<a name="line-629"></a>Bottom line: FM_Avoid is unused for now (Nov 14).
<a name="line-630"></a>Note: T5321Fun got faster when I disabled FM_Avoid
<a name="line-631"></a>      T5837 did too, but it's pathalogical anyway
<a name="line-632"></a>
<a name="line-633"></a>Note [Phantoms in the flattener]
<a name="line-634"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-635"></a>Suppose we have
<a name="line-636"></a>
<a name="line-637"></a>data Proxy p = Proxy
<a name="line-638"></a>
<a name="line-639"></a>and we're flattening (Proxy ty) w.r.t. ReprEq. Then, we know that `ty`
<a name="line-640"></a>is really irrelevant -- it will be ignored when solving for representational
<a name="line-641"></a>equality later on. So, we omit flattening `ty` entirely. This may
<a name="line-642"></a>violate the expectation of "xi"s for a bit, but the canonicaliser will
<a name="line-643"></a>soon throw out the phantoms when decomposing a TyConApp. (Or, the
<a name="line-644"></a>canonicaliser will emit an insoluble, in which case the unflattened version
<a name="line-645"></a>yields a better error message anyway.)
<a name="line-646"></a>
<a name="line-647"></a>Note [flatten_many performance]
<a name="line-648"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-649"></a>In programs with lots of type-level evaluation, flatten_many becomes
<a name="line-650"></a>part of a tight loop. For example, see test perf/compiler/T9872a, which
<a name="line-651"></a>calls flatten_many a whopping 7,106,808 times. It is thus important
<a name="line-652"></a>that flatten_many be efficient.
<a name="line-653"></a>
<a name="line-654"></a>Performance testing showed that the current implementation is indeed
<a name="line-655"></a>efficient. It's critically important that zipWithAndUnzipM be
<a name="line-656"></a>specialized to TcS, and it's also quite helpful to actually `inline`
<a name="line-657"></a>it. On test T9872a, here are the allocation stats (Dec 16, 2014):
<a name="line-658"></a>
<a name="line-659"></a> * Unspecialized, uninlined:     8,472,613,440 bytes allocated in the heap
<a name="line-660"></a> * Specialized, uninlined:       6,639,253,488 bytes allocated in the heap
<a name="line-661"></a> * Specialized, inlined:         6,281,539,792 bytes allocated in the heap
<a name="line-662"></a>
<a name="line-663"></a>To improve performance even further, flatten_many_nom is split off
<a name="line-664"></a>from flatten_many, as nominal equality is the common case. This would
<a name="line-665"></a>be natural to write using mapAndUnzipM, but even inlined, that function
<a name="line-666"></a>is not as performant as a hand-written loop.
<a name="line-667"></a>
<a name="line-668"></a> * mapAndUnzipM, inlined:        7,463,047,432 bytes allocated in the heap
<a name="line-669"></a> * hand-written recursion:       5,848,602,848 bytes allocated in the heap
<a name="line-670"></a>
<a name="line-671"></a>If you make any change here, pay close attention to the T9872{a,b,c} tests
<a name="line-672"></a>and T5321Fun.
<a name="line-673"></a>
<a name="line-674"></a>If we need to make this yet more performant, a possible way forward is to
<a name="line-675"></a>duplicate the flattener code for the nominal case, and make that case
<a name="line-676"></a>faster. This doesn't seem quite worth it, yet.
<a name="line-677"></a>
<a name="line-678"></a>-}</span>
<a name="line-679"></a>
<a name="line-680"></a><a name="flatten"></a><span class='hs-comment'>------------------</span>
<a name="line-681"></a><span class='hs-definition'>flatten</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-682"></a><span class='hs-definition'>flatten</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty</span>
<a name="line-683"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runFlatten</span> <span class='hs-layout'>(</span><span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-684"></a>  <span class='hs-keyword'>where</span>
<a name="line-685"></a>    <span class='hs-varid'>fmode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFlattenEnv</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span>
<a name="line-686"></a>
<a name="line-687"></a><a name="flattenMany"></a><span class='hs-definition'>flattenMany</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span>
<a name="line-688"></a>            <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcCoercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-689"></a><span class='hs-comment'>-- Flatten a bunch of types all at once. Roles on the coercions returned</span>
<a name="line-690"></a><span class='hs-comment'>-- always match the corresponding roles passed in.</span>
<a name="line-691"></a><span class='hs-definition'>flattenMany</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-692"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runFlatten</span> <span class='hs-layout'>(</span><span class='hs-varid'>flatten_many</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-693"></a>  <span class='hs-keyword'>where</span>
<a name="line-694"></a>    <span class='hs-varid'>fmode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFlattenEnv</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span>
<a name="line-695"></a>
<a name="line-696"></a><a name="flattenFamApp"></a><span class='hs-definition'>flattenFamApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span>
<a name="line-697"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-698"></a><span class='hs-definition'>flattenFamApp</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-699"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>runFlatten</span> <span class='hs-layout'>(</span><span class='hs-varid'>flatten_fam_app</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-700"></a>  <span class='hs-keyword'>where</span>
<a name="line-701"></a>    <span class='hs-varid'>fmode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkFlattenEnv</span> <span class='hs-varid'>mode</span> <span class='hs-varid'>ev</span>
<a name="line-702"></a>
<a name="line-703"></a><a name="flatten_many"></a><span class='hs-comment'>------------------</span>
<a name="line-704"></a><span class='hs-definition'>flatten_many</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Role</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcCoercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-705"></a><span class='hs-comment'>-- Coercions :: Xi ~ Type, at roles given</span>
<a name="line-706"></a><span class='hs-comment'>-- Returns True iff (no flattening happened)</span>
<a name="line-707"></a><span class='hs-comment'>-- NB: The EvVar inside the 'fe_ev :: CtEvidence' is unused,</span>
<a name="line-708"></a><span class='hs-comment'>--     we merely want (a) Given/Solved/Derived/Wanted info</span>
<a name="line-709"></a><span class='hs-comment'>--                    (b) the GivenLoc/WantedLoc for when we create new evidence</span>
<a name="line-710"></a><span class='hs-definition'>flatten_many</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-711"></a><span class='hs-comment'>-- See Note [flatten_many performance]</span>
<a name="line-712"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>inline</span> <span class='hs-varid'>zipWithAndUnzipM</span> <span class='hs-varid'>go</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-713"></a>  <span class='hs-keyword'>where</span>
<a name="line-714"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>Nominal</span>          <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>setFEEqRel</span> <span class='hs-varid'>fmode</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span>  <span class='hs-varid'>ty</span>
<a name="line-715"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>Representational</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>setFEEqRel</span> <span class='hs-varid'>fmode</span> <span class='hs-conid'>ReprEq</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span>
<a name="line-716"></a>    <span class='hs-varid'>go</span> <span class='hs-conid'>Phantom</span>          <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- See Note [Phantoms in the flattener]</span>
<a name="line-717"></a>                             <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcPhantomCo</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-718"></a>
<a name="line-719"></a><a name="flatten_many_nom"></a><span class='hs-comment'>-- | Like 'flatten_many', but assumes that every role is nominal.</span>
<a name="line-720"></a><span class='hs-definition'>flatten_many_nom</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>Xi</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcCoercion</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-721"></a><span class='hs-definition'>flatten_many_nom</span> <span class='hs-keyword'>_</span>     <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>)</span>
<a name="line-722"></a><span class='hs-comment'>-- See Note [flatten_many performance]</span>
<a name="line-723"></a><span class='hs-definition'>flatten_many_nom</span> <span class='hs-varid'>fmode</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-conop'>:</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-724"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-varid'>fmode</span> <span class='hs-varop'>==</span> <span class='hs-conid'>NomEq</span> <span class='hs-layout'>)</span>
<a name="line-725"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>ty</span>
<a name="line-726"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_many_nom</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tys</span>
<a name="line-727"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-conop'>:</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-conop'>:</span><span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-728"></a>
<a name="line-729"></a><a name="flatten_one"></a><span class='hs-comment'>------------------</span>
<a name="line-730"></a><span class='hs-definition'>flatten_one</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-731"></a><span class='hs-comment'>-- Flatten a type to get rid of type function applications, returning</span>
<a name="line-732"></a><span class='hs-comment'>-- the new type-function-free type, and a collection of new equality</span>
<a name="line-733"></a><span class='hs-comment'>-- constraints.  See Note [Flattening] for more detail.</span>
<a name="line-734"></a><span class='hs-comment'>--</span>
<a name="line-735"></a><span class='hs-comment'>-- Postcondition: Coercion :: Xi ~ TcType</span>
<a name="line-736"></a><span class='hs-comment'>-- The role on the result coercion matches the EqRel in the FlattenEnv</span>
<a name="line-737"></a>
<a name="line-738"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>xi</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>LitTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span> <span class='hs-varid'>xi</span><span class='hs-layout'>)</span>
<a name="line-739"></a>
<a name="line-740"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-741"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flattenTyVar</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tv</span>
<a name="line-742"></a>
<a name="line-743"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-layout'>(</span><span class='hs-conid'>AppTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-744"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span><span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>ty1</span>
<a name="line-745"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>fe_eq_rel</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>,</span> <span class='hs-varid'>nextRole</span> <span class='hs-varid'>xi1</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-746"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>NomEq</span><span class='hs-layout'>,</span>  <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_rhs</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>co1</span> <span class='hs-conid'>NomEq</span>
<a name="line-747"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>ReprEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_rhs</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>co1</span> <span class='hs-conid'>NomEq</span>
<a name="line-748"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>ReprEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Representational</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_rhs</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>co1</span> <span class='hs-conid'>ReprEq</span>
<a name="line-749"></a>           <span class='hs-layout'>(</span><span class='hs-conid'>ReprEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>Phantom</span><span class='hs-layout'>)</span>          <span class='hs-keyglyph'>-&gt;</span>
<a name="line-750"></a>             <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkAppTy</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span> <span class='hs-varop'>`mkTcAppCo`</span> <span class='hs-varid'>mkTcNomReflCo</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-751"></a>  <span class='hs-keyword'>where</span>
<a name="line-752"></a>    <span class='hs-varid'>flatten_rhs</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>eq_rel2</span>
<a name="line-753"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span><span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>setFEEqRel</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>eq_rel2</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty2</span>
<a name="line-754"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten/appty"</span>
<a name="line-755"></a>                      <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi1</span> <span class='hs-varop'>$$</span>
<a name="line-756"></a>                       <span class='hs-varid'>ppr</span> <span class='hs-varid'>co1</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xi2</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span>
<a name="line-757"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>role1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span>
<a name="line-758"></a>                 <span class='hs-varid'>role2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel2</span>
<a name="line-759"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkAppTy</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span>
<a name="line-760"></a>                    <span class='hs-layout'>,</span> <span class='hs-varid'>mkTcTransAppCo</span> <span class='hs-varid'>role1</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>ty1</span>
<a name="line-761"></a>                                     <span class='hs-varid'>role2</span> <span class='hs-varid'>co2</span> <span class='hs-varid'>xi2</span> <span class='hs-varid'>ty2</span>
<a name="line-762"></a>                                     <span class='hs-varid'>role1</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>  <span class='hs-comment'>-- output should match fmode</span>
<a name="line-763"></a>
<a name="line-764"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-layout'>(</span><span class='hs-conid'>FunTy</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-765"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span><span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>ty1</span>
<a name="line-766"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi2</span><span class='hs-layout'>,</span><span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>ty2</span>
<a name="line-767"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkFunTy</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xi2</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcFunCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-768"></a>
<a name="line-769"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-layout'>(</span><span class='hs-conid'>TyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span>
<a name="line-770"></a>
<a name="line-771"></a>  <span class='hs-comment'>-- Expand type synonyms that mention type families</span>
<a name="line-772"></a>  <span class='hs-comment'>-- on the RHS; see Note [Flattening synonyms]</span>
<a name="line-773"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tenv</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys'</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcExpandTyCon_maybe</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-774"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>expanded_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkAppTys</span> <span class='hs-layout'>(</span><span class='hs-varid'>substTy</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTopTvSubst</span> <span class='hs-varid'>tenv</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys'</span>
<a name="line-775"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fe_mode</span> <span class='hs-varid'>fmode</span> <span class='hs-keyword'>of</span>
<a name="line-776"></a>      <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>anyNameEnv</span> <span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConsOfType</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-777"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>expanded_ty</span>
<a name="line-778"></a>                    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-779"></a>                   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flattenTyConApp</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-780"></a>      <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flattenTyConApp</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-781"></a>
<a name="line-782"></a>  <span class='hs-comment'>-- Otherwise, it's a type function application, and we have to</span>
<a name="line-783"></a>  <span class='hs-comment'>-- flatten it away as well, and generate a new given equality constraint</span>
<a name="line-784"></a>  <span class='hs-comment'>-- between the application and a newly generated flattening skolem variable.</span>
<a name="line-785"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-786"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flatten_fam_app</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-787"></a>
<a name="line-788"></a>  <span class='hs-comment'>-- For * a normal data type application</span>
<a name="line-789"></a>  <span class='hs-comment'>--     * data family application</span>
<a name="line-790"></a>  <span class='hs-comment'>-- we just recursively flatten the arguments.</span>
<a name="line-791"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-792"></a><span class='hs-comment'>-- FM_Avoid stuff commented out; see Note [Lazy flattening]</span>
<a name="line-793"></a><span class='hs-comment'>--  , let fmode' = case fmode of  -- Switch off the flat_top bit in FM_Avoid</span>
<a name="line-794"></a><span class='hs-comment'>--                   FE { fe_mode = FM_Avoid tv _ }</span>
<a name="line-795"></a><span class='hs-comment'>--                     -&gt; fmode { fe_mode = FM_Avoid tv False }</span>
<a name="line-796"></a><span class='hs-comment'>--                   _ -&gt; fmode</span>
<a name="line-797"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flattenTyConApp</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-798"></a>
<a name="line-799"></a><span class='hs-definition'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>ty</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>ForAllTy</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-800"></a><span class='hs-comment'>-- We allow for-alls when, but only when, no type function</span>
<a name="line-801"></a><span class='hs-comment'>-- applications inside the forall involve the bound type variables.</span>
<a name="line-802"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>rho</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitForAllTys</span> <span class='hs-varid'>ty</span>
<a name="line-803"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>rho'</span><span class='hs-layout'>,</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-layout'>(</span><span class='hs-varid'>setFEMode</span> <span class='hs-varid'>fmode</span> <span class='hs-conid'>FM_SubstOnly</span><span class='hs-layout'>)</span> <span class='hs-varid'>rho</span>
<a name="line-804"></a>                         <span class='hs-comment'>-- Substitute only under a forall</span>
<a name="line-805"></a>                         <span class='hs-comment'>-- See Note [Flattening under a forall]</span>
<a name="line-806"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkForAllTys</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>rho'</span><span class='hs-layout'>,</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>mkTcForAllCo</span> <span class='hs-varid'>co</span> <span class='hs-varid'>tvs</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-807"></a>
<a name="line-808"></a><a name="flattenTyConApp"></a><span class='hs-definition'>flattenTyConApp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-809"></a><span class='hs-definition'>flattenTyConApp</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-810"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-varid'>fmode</span> <span class='hs-keyword'>of</span>
<a name="line-811"></a>                         <span class='hs-conid'>NomEq</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_many_nom</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tys</span>
<a name="line-812"></a>                         <span class='hs-conid'>ReprEq</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_many</span> <span class='hs-varid'>fmode</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConRolesX</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-813"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-varid'>role</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-814"></a>  <span class='hs-keyword'>where</span>
<a name="line-815"></a>    <span class='hs-varid'>role</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span>
<a name="line-816"></a>
<a name="line-817"></a><span class='hs-comment'>{-
<a name="line-818"></a>Note [Flattening synonyms]
<a name="line-819"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-820"></a>Not expanding synonyms aggressively improves error messages, and
<a name="line-821"></a>keeps types smaller. But we need to take care.
<a name="line-822"></a>
<a name="line-823"></a>Suppose
<a name="line-824"></a>   type T a = a -&gt; a
<a name="line-825"></a>and we want to flatten the type (T (F a)).  Then we can safely flatten
<a name="line-826"></a>the (F a) to a skolem, and return (T fsk).  We don't need to expand the
<a name="line-827"></a>synonym.  This works because TcTyConAppCo can deal with synonyms
<a name="line-828"></a>(unlike TyConAppCo), see Note [TcCoercions] in TcEvidence.
<a name="line-829"></a>
<a name="line-830"></a>But (Trac #8979) for
<a name="line-831"></a>   type T a = (F a, a)    where F is a type function
<a name="line-832"></a>we must expand the synonym in (say) T Int, to expose the type function
<a name="line-833"></a>to the flattener.
<a name="line-834"></a>
<a name="line-835"></a>
<a name="line-836"></a>Note [Flattening under a forall]
<a name="line-837"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-838"></a>Under a forall, we
<a name="line-839"></a>  (a) MUST apply the inert substitution
<a name="line-840"></a>  (b) MUST NOT flatten type family applications
<a name="line-841"></a>Hence FMSubstOnly.
<a name="line-842"></a>
<a name="line-843"></a>For (a) consider   c ~ a, a ~ T (forall b. (b, [c]))
<a name="line-844"></a>If we don't apply the c~a substitution to the second constraint
<a name="line-845"></a>we won't see the occurs-check error.
<a name="line-846"></a>
<a name="line-847"></a>For (b) consider  (a ~ forall b. F a b), we don't want to flatten
<a name="line-848"></a>to     (a ~ forall b.fsk, F a b ~ fsk)
<a name="line-849"></a>because now the 'b' has escaped its scope.  We'd have to flatten to
<a name="line-850"></a>       (a ~ forall b. fsk b, forall b. F a b ~ fsk b)
<a name="line-851"></a>and we have not begun to think about how to make that work!
<a name="line-852"></a>
<a name="line-853"></a>************************************************************************
<a name="line-854"></a>*                                                                      *
<a name="line-855"></a>             Flattening a type-family application
<a name="line-856"></a>*                                                                      *
<a name="line-857"></a>************************************************************************
<a name="line-858"></a>-}</span>
<a name="line-859"></a>
<a name="line-860"></a><a name="flatten_fam_app"></a><span class='hs-definition'>flatten_fam_app</span><span class='hs-layout'>,</span> <span class='hs-varid'>flatten_exact_fam_app</span><span class='hs-layout'>,</span> <span class='hs-varid'>flatten_exact_fam_app_fully</span>
<a name="line-861"></a>  <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyCon</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-862"></a>  <span class='hs-comment'>--   flatten_fam_app            can be over-saturated</span>
<a name="line-863"></a>  <span class='hs-comment'>--   flatten_exact_fam_app       is exactly saturated</span>
<a name="line-864"></a>  <span class='hs-comment'>--   flatten_exact_fam_app_fully lifts out the application to top level</span>
<a name="line-865"></a>  <span class='hs-comment'>-- Postcondition: Coercion :: Xi ~ F tys</span>
<a name="line-866"></a><span class='hs-definition'>flatten_fam_app</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>  <span class='hs-comment'>-- Can be over-saturated</span>
<a name="line-867"></a>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;=</span> <span class='hs-varid'>length</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>)</span>  <span class='hs-comment'>-- Type functions are saturated</span>
<a name="line-868"></a>                 <span class='hs-comment'>-- The type function might be *over* saturated</span>
<a name="line-869"></a>                 <span class='hs-comment'>-- in which case the remaining arguments should</span>
<a name="line-870"></a>                 <span class='hs-comment'>-- be dealt with by AppTys</span>
<a name="line-871"></a>      <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>tys1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys_rest</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>splitAt</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyConArity</span> <span class='hs-varid'>tc</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-872"></a>         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_exact_fam_app</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys1</span>
<a name="line-873"></a>               <span class='hs-comment'>-- co1 :: xi1 ~ F tys1</span>
<a name="line-874"></a>
<a name="line-875"></a>               <span class='hs-comment'>-- all Nominal roles b/c the tycon is oversaturated</span>
<a name="line-876"></a>         <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis_rest</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos_rest</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_many</span> <span class='hs-varid'>fmode</span> <span class='hs-layout'>(</span><span class='hs-varid'>repeat</span> <span class='hs-conid'>Nominal</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys_rest</span>
<a name="line-877"></a>               <span class='hs-comment'>-- cos_res :: xis_rest ~ tys_rest</span>
<a name="line-878"></a>         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkAppTys</span> <span class='hs-varid'>xi1</span> <span class='hs-varid'>xis_rest</span>   <span class='hs-comment'>-- NB mkAppTys: rhs_xi might not be a type variable</span>
<a name="line-879"></a>                                            <span class='hs-comment'>--    cf Trac #5655</span>
<a name="line-880"></a>                  <span class='hs-layout'>,</span> <span class='hs-varid'>mkTcAppCos</span> <span class='hs-varid'>co1</span> <span class='hs-varid'>cos_rest</span> <span class='hs-comment'>-- (rhs_xi :: F xis) ; (F cos :: F xis ~ F tys)</span>
<a name="line-881"></a>                  <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-882"></a>
<a name="line-883"></a><a name="flatten_exact_fam_app"></a><span class='hs-definition'>flatten_exact_fam_app</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-884"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>fe_mode</span> <span class='hs-varid'>fmode</span> <span class='hs-keyword'>of</span>
<a name="line-885"></a>       <span class='hs-conid'>FM_FlattenAll</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>flatten_exact_fam_app_fully</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-886"></a>
<a name="line-887"></a>       <span class='hs-conid'>FM_SubstOnly</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_many</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-888"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-889"></a>                                   <span class='hs-layout'>,</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-890"></a>
<a name="line-891"></a>       <span class='hs-conid'>FM_Avoid</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>flat_top</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-892"></a>         <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_many</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>roles</span> <span class='hs-varid'>tys</span>
<a name="line-893"></a>            <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>flat_top</span> <span class='hs-varop'>||</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>xis</span>
<a name="line-894"></a>              <span class='hs-keyword'>then</span> <span class='hs-varid'>flatten_exact_fam_app_fully</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-895"></a>              <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-896"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-897"></a>  <span class='hs-keyword'>where</span>
<a name="line-898"></a>    <span class='hs-comment'>-- These are always going to be Nominal for now,</span>
<a name="line-899"></a>    <span class='hs-comment'>-- but not if #8177 is implemented</span>
<a name="line-900"></a>    <span class='hs-varid'>roles</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyConRolesX</span> <span class='hs-layout'>(</span><span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span> <span class='hs-varid'>tc</span>
<a name="line-901"></a>
<a name="line-902"></a><a name="flatten_exact_fam_app_fully"></a><span class='hs-definition'>flatten_exact_fam_app_fully</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-903"></a>  <span class='hs-comment'>-- See Note [Reduce type family applications eagerly]</span>
<a name="line-904"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>try_to_reduce</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-conid'>False</span> <span class='hs-varid'>id</span> <span class='hs-varop'>$</span>
<a name="line-905"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>xis</span><span class='hs-layout'>,</span> <span class='hs-varid'>cos</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_many_nom</span> <span class='hs-layout'>(</span><span class='hs-varid'>setFEEqRel</span> <span class='hs-layout'>(</span><span class='hs-varid'>setFEMode</span> <span class='hs-varid'>fmode</span> <span class='hs-conid'>FM_FlattenAll</span><span class='hs-layout'>)</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span> <span class='hs-varid'>tys</span>
<a name="line-906"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ret_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcTyConAppCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>cos</span>
<a name="line-907"></a>              <span class='hs-comment'>-- ret_co :: F xis ~ F tys</span>
<a name="line-908"></a>
<a name="line-909"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>lookupFlatCache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-910"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ct</span> <span class='hs-keyword'>of</span>
<a name="line-911"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>flav</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- co :: F xis ~ fsk</span>
<a name="line-912"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>flav</span><span class='hs-layout'>,</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span> <span class='hs-varop'>`canRewriteOrSameFR`</span> <span class='hs-layout'>(</span><span class='hs-varid'>feFlavourRole</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span>
<a name="line-913"></a>             <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-comment'>-- Usable hit in the flat-cache</span>
<a name="line-914"></a>                 <span class='hs-comment'>-- We certainly *can* use a Wanted for a Wanted</span>
<a name="line-915"></a>                <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten/flat-cache hit"</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>xis</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-916"></a>                   <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsk_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>rhs_ty</span>
<a name="line-917"></a>                          <span class='hs-comment'>-- The fsk may already have been unified, so flatten it</span>
<a name="line-918"></a>                          <span class='hs-comment'>-- fsk_co :: fsk_xi ~ fsk</span>
<a name="line-919"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsk_xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk_co</span> <span class='hs-varop'>`mkTcTransCo`</span>
<a name="line-920"></a>                                     <span class='hs-varid'>maybeTcSubCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>fe_eq_rel</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span>
<a name="line-921"></a>                                                  <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-varop'>`mkTcTransCo`</span>
<a name="line-922"></a>                                     <span class='hs-varid'>ret_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-923"></a>                                    <span class='hs-comment'>-- :: fsk_xi ~ F xis</span>
<a name="line-924"></a>
<a name="line-925"></a>           <span class='hs-comment'>-- Try to reduce the family application right now</span>
<a name="line-926"></a>           <span class='hs-comment'>-- See Note [Reduce type family applications eagerly]</span>
<a name="line-927"></a>           <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>try_to_reduce</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span> <span class='hs-conid'>True</span> <span class='hs-layout'>(</span><span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>ret_co</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-928"></a>                <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fam_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span>
<a name="line-929"></a>                   <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newFlattenSkolem</span> <span class='hs-layout'>(</span><span class='hs-varid'>fe_flavour</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span>
<a name="line-930"></a>                                                   <span class='hs-layout'>(</span><span class='hs-varid'>fe_loc</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span>
<a name="line-931"></a>                                                   <span class='hs-varid'>fam_ty</span>
<a name="line-932"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>fsk_ty</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>fsk</span>
<a name="line-933"></a>                         <span class='hs-varid'>co</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvCoercion</span> <span class='hs-varid'>ev</span>
<a name="line-934"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>extendFlatCache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>fsk_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctEvFlavour</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-935"></a>
<a name="line-936"></a>                   <span class='hs-comment'>-- The new constraint (F xis ~ fsk) is not necessarily inert</span>
<a name="line-937"></a>                   <span class='hs-comment'>-- (e.g. the LHS may be a redex) so we must put it in the work list</span>
<a name="line-938"></a>                   <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span>
<a name="line-939"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fun</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span>
<a name="line-940"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span>
<a name="line-941"></a>                                        <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fsk</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fsk</span> <span class='hs-layout'>}</span>
<a name="line-942"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>emitFlatWork</span> <span class='hs-varid'>ct</span>
<a name="line-943"></a>
<a name="line-944"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flatten/flat-cache miss"</span> <span class='hs-varop'>$</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>fam_ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>fsk</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-945"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>fsk_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>maybeTcSubCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>fe_eq_rel</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span>
<a name="line-946"></a>                                                  <span class='hs-layout'>(</span><span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span>
<a name="line-947"></a>                                     <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>ret_co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-948"></a>        <span class='hs-layout'>}</span>
<a name="line-949"></a>
<a name="line-950"></a>  <span class='hs-keyword'>where</span>
<a name="line-951"></a>    <span class='hs-varid'>try_to_reduce</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyCon</span>   <span class='hs-comment'>-- F, family tycon</span>
<a name="line-952"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- args, not necessarily flattened</span>
<a name="line-953"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>    <span class='hs-comment'>-- add to the flat cache?</span>
<a name="line-954"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span>   <span class='hs-conid'>TcCoercion</span>     <span class='hs-comment'>-- :: xi ~ F args</span>
<a name="line-955"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcCoercion</span> <span class='hs-layout'>)</span>   <span class='hs-comment'>-- what to return from outer function</span>
<a name="line-956"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- continuation upon failure</span>
<a name="line-957"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-958"></a>    <span class='hs-varid'>try_to_reduce</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-varid'>cache</span> <span class='hs-varid'>update_co</span> <span class='hs-varid'>k</span>
<a name="line-959"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>matchFam</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span>
<a name="line-960"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_match</span> <span class='hs-keyword'>of</span>
<a name="line-961"></a>               <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>norm_co</span><span class='hs-layout'>,</span> <span class='hs-varid'>norm_ty</span><span class='hs-layout'>)</span>
<a name="line-962"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Eager T.F. reduction success"</span> <span class='hs-varop'>$</span>
<a name="line-963"></a>                         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>tys</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>norm_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>cache</span><span class='hs-keyglyph'>]</span>
<a name="line-964"></a>                       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>norm_ty</span>
<a name="line-965"></a>                       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>co</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>norm_co</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>final_co</span>
<a name="line-966"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>when</span> <span class='hs-varid'>cache</span> <span class='hs-varop'>$</span>
<a name="line-967"></a>                         <span class='hs-varid'>extendFlatCache</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>tys</span> <span class='hs-layout'>(</span><span class='hs-varid'>co</span><span class='hs-layout'>,</span> <span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span>
<a name="line-968"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>xi</span><span class='hs-layout'>,</span> <span class='hs-varid'>update_co</span> <span class='hs-varop'>$</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-varid'>co</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-969"></a>               <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>k</span> <span class='hs-layout'>}</span>
<a name="line-970"></a>
<a name="line-971"></a><span class='hs-comment'>{- Note [Reduce type family applications eagerly]
<a name="line-972"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-973"></a>If we come across a type-family application like (Append (Cons x Nil) t),
<a name="line-974"></a>then, rather than flattening to a skolem etc, we may as well just reduce
<a name="line-975"></a>it on the spot to (Cons x t).  This saves a lot of intermediate steps.
<a name="line-976"></a>Examples that are helped are tests T9872, and T5321Fun.
<a name="line-977"></a>
<a name="line-978"></a>Performance testing indicates that it's best to try this *twice*, once
<a name="line-979"></a>before flattening arguments and once after flattening arguments.
<a name="line-980"></a>Adding the extra reduction attempt before flattening arguments cut
<a name="line-981"></a>the allocation amounts for the T9872{a,b,c} tests by half. Testing
<a name="line-982"></a>also indicated that the early reduction should not use the flat-cache,
<a name="line-983"></a>but that the later reduction should. It's possible that with more
<a name="line-984"></a>examples, we might learn that these knobs should be set differently.
<a name="line-985"></a>
<a name="line-986"></a>Once we've got a flat rhs, we extend the flatten-cache to record the
<a name="line-987"></a>result.  Doing so can save lots of work when the same redex shows up
<a name="line-988"></a>more than once.  Note that we record the link from the redex all the
<a name="line-989"></a>way to its *final* value, not just the single step reduction.
<a name="line-990"></a>
<a name="line-991"></a>************************************************************************
<a name="line-992"></a>*                                                                      *
<a name="line-993"></a>             Flattening a type variable
<a name="line-994"></a>*                                                                      *
<a name="line-995"></a>************************************************************************
<a name="line-996"></a>
<a name="line-997"></a>
<a name="line-998"></a>Note [The inert equalities]
<a name="line-999"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1000"></a>
<a name="line-1001"></a>Definition [Can-rewrite relation]
<a name="line-1002"></a>A "can-rewrite" relation between flavours, written f1 &gt;= f2, is a
<a name="line-1003"></a>binary relation with the following properties
<a name="line-1004"></a>
<a name="line-1005"></a>  R1.  &gt;= is transitive
<a name="line-1006"></a>  R2.  If f1 &gt;= f, and f2 &gt;= f,
<a name="line-1007"></a>       then either f1 &gt;= f2 or f2 &gt;= f1
<a name="line-1008"></a>
<a name="line-1009"></a>Lemma.  If f1 &gt;= f then f1 &gt;= f1
<a name="line-1010"></a>Proof.  By property (R2), with f1=f2
<a name="line-1011"></a>
<a name="line-1012"></a>Definition [Generalised substitution]
<a name="line-1013"></a>A "generalised substitution" S is a set of triples (a -f-&gt; t), where
<a name="line-1014"></a>  a is a type variable
<a name="line-1015"></a>  t is a type
<a name="line-1016"></a>  f is a flavour
<a name="line-1017"></a>such that
<a name="line-1018"></a>  (WF1) if (a -f1-&gt; t1) in S
<a name="line-1019"></a>           (a -f2-&gt; t2) in S
<a name="line-1020"></a>        then neither (f1 &gt;= f2) nor (f2 &gt;= f1) hold
<a name="line-1021"></a>  (WF2) if (a -f-&gt; t) is in S, then t /= a
<a name="line-1022"></a>
<a name="line-1023"></a>Definition [Applying a generalised substitution]
<a name="line-1024"></a>If S is a generalised substitution
<a name="line-1025"></a>   S(f,a) = t,  if (a -fs-&gt; t) in S, and fs &gt;= f
<a name="line-1026"></a>          = a,  otherwise
<a name="line-1027"></a>Application extends naturally to types S(f,t), modulo roles.
<a name="line-1028"></a>See Note [Flavours with roles].
<a name="line-1029"></a>
<a name="line-1030"></a>Theorem: S(f,a) is well defined as a function.
<a name="line-1031"></a>Proof: Suppose (a -f1-&gt; t1) and (a -f2-&gt; t2) are both in S,
<a name="line-1032"></a>               and  f1 &gt;= f and f2 &gt;= f
<a name="line-1033"></a>       Then by (R2) f1 &gt;= f2 or f2 &gt;= f1, which contradicts (WF)
<a name="line-1034"></a>
<a name="line-1035"></a>Notation: repeated application.
<a name="line-1036"></a>  S^0(f,t)     = t
<a name="line-1037"></a>  S^(n+1)(f,t) = S(f, S^n(t))
<a name="line-1038"></a>
<a name="line-1039"></a>Definition: inert generalised substitution
<a name="line-1040"></a>A generalised substitution S is "inert" iff
<a name="line-1041"></a>
<a name="line-1042"></a>  (IG1) there is an n such that
<a name="line-1043"></a>        for every f,t, S^n(f,t) = S^(n+1)(f,t)
<a name="line-1044"></a>
<a name="line-1045"></a>  (IG2) if (b -f-&gt; t) in S, and f &gt;= f, then S(f,t) = t
<a name="line-1046"></a>        that is, each individual binding is "self-stable"
<a name="line-1047"></a>
<a name="line-1048"></a>----------------------------------------------------------------
<a name="line-1049"></a>Our main invariant:
<a name="line-1050"></a>   the inert CTyEqCans should be an inert generalised substitution
<a name="line-1051"></a>----------------------------------------------------------------
<a name="line-1052"></a>
<a name="line-1053"></a>Note that inertness is not the same as idempotence.  To apply S to a
<a name="line-1054"></a>type, you may have to apply it recursive.  But inertness does
<a name="line-1055"></a>guarantee that this recursive use will terminate.
<a name="line-1056"></a>
<a name="line-1057"></a>---------- The main theorem --------------
<a name="line-1058"></a>   Suppose we have a "work item"
<a name="line-1059"></a>       a -fw-&gt; t
<a name="line-1060"></a>   and an inert generalised substitution S,
<a name="line-1061"></a>   such that
<a name="line-1062"></a>      (T1) S(fw,a) = a     -- LHS of work-item is a fixpoint of S(fw,_)
<a name="line-1063"></a>      (T2) S(fw,t) = t     -- RHS of work-item is a fixpoint of S(fw,_)
<a name="line-1064"></a>      (T3) a not in t      -- No occurs check in the work item
<a name="line-1065"></a>
<a name="line-1066"></a>      (K1) if (a -fs-&gt; s) is in S then not (fw &gt;= fs)
<a name="line-1067"></a>      (K2) if (b -fs-&gt; s) is in S, where b /= a, then
<a name="line-1068"></a>              (K2a) not (fs &gt;= fs)
<a name="line-1069"></a>           or (K2b) not (fw &gt;= fs)
<a name="line-1070"></a>           or (K2c) a not in s
<a name="line-1071"></a>      (K3) If (b -fs-&gt; s) is in S with (fw &gt;= fs), then
<a name="line-1072"></a>        (K3a) If the role of fs is nominal: s /= a
<a name="line-1073"></a>        (K3b) If the role of fs is representational: EITHER
<a name="line-1074"></a>                a not in s, OR
<a name="line-1075"></a>                the path from the top of s to a includes at least one non-newtype
<a name="line-1076"></a>
<a name="line-1077"></a>   then the extended substition T = S+(a -fw-&gt; t)
<a name="line-1078"></a>   is an inert generalised substitution.
<a name="line-1079"></a>
<a name="line-1080"></a>The idea is that
<a name="line-1081"></a>* (T1-2) are guaranteed by exhaustively rewriting the work-item
<a name="line-1082"></a>  with S(fw,_).
<a name="line-1083"></a>
<a name="line-1084"></a>* T3 is guaranteed by a simple occurs-check on the work item.
<a name="line-1085"></a>
<a name="line-1086"></a>* (K1-3) are the "kick-out" criteria.  (As stated, they are really the
<a name="line-1087"></a>  "keep" criteria.) If the current inert S contains a triple that does
<a name="line-1088"></a>  not satisfy (K1-3), then we remove it from S by "kicking it out",
<a name="line-1089"></a>  and re-processing it.
<a name="line-1090"></a>
<a name="line-1091"></a>* Note that kicking out is a Bad Thing, because it means we have to
<a name="line-1092"></a>  re-process a constraint.  The less we kick out, the better.
<a name="line-1093"></a>  TODO: Make sure that kicking out really *is* a Bad Thing. We've assumed
<a name="line-1094"></a>  this but haven't done the empirical study to check.
<a name="line-1095"></a>
<a name="line-1096"></a>* Assume we have  G&gt;=G, G&gt;=W, D&gt;=D, and that's all.  Then, when performing
<a name="line-1097"></a>  a unification we add a new given  a -G-&gt; ty.  But doing so does NOT require
<a name="line-1098"></a>  us to kick out an inert wanted that mentions a, because of (K2a).  This
<a name="line-1099"></a>  is a common case, hence good not to kick out.
<a name="line-1100"></a>
<a name="line-1101"></a>* Lemma (L1): The conditions of the Main Theorem imply that there is no
<a name="line-1102"></a>              (a fs-&gt; t) in S, s.t.  (fs &gt;= fw).
<a name="line-1103"></a>  Proof. Suppose the contrary (fs &gt;= fw).  Then because of (T1),
<a name="line-1104"></a>  S(fw,a)=a.  But since fs&gt;=fw, S(fw,a) = s, hence s=a.  But now we
<a name="line-1105"></a>  have (a -fs-&gt; a) in S, which contradicts (WF2).
<a name="line-1106"></a>
<a name="line-1107"></a>* The extended substitution satisfies (WF1) and (WF2)
<a name="line-1108"></a>  - (K1) plus (L1) guarantee that the extended substiution satisfies (WF1).
<a name="line-1109"></a>  - (T3) guarantees (WF2).
<a name="line-1110"></a>
<a name="line-1111"></a>* (K2) is about inertness.  Intuitively, any infinite chain T^0(f,t),
<a name="line-1112"></a>  T^1(f,t), T^2(f,T).... must pass through the new work item infnitely
<a name="line-1113"></a>  often, since the substution without the work item is inert; and must
<a name="line-1114"></a>  pass through at least one of the triples in S infnitely often.
<a name="line-1115"></a>
<a name="line-1116"></a>  - (K2a): if not(fs&gt;=fs) then there is no f that fs can rewrite (fs&gt;=f),
<a name="line-1117"></a>    and hence this triple never plays a role in application S(f,a).
<a name="line-1118"></a>    It is always safe to extend S with such a triple.
<a name="line-1119"></a>
<a name="line-1120"></a>    (NB: we could strengten K1) in this way too, but see K3.
<a name="line-1121"></a>
<a name="line-1122"></a>  - (K2b): If this holds, we can't pass through this triple infinitely
<a name="line-1123"></a>    often, because if we did then fs&gt;=f, fw&gt;=f, hence fs&gt;=fw,
<a name="line-1124"></a>    contradicting (L1), or fw&gt;=fs contradicting K2b.
<a name="line-1125"></a>
<a name="line-1126"></a>  - (K2c): if a not in s, we hae no further opportunity to apply the
<a name="line-1127"></a>    work item.
<a name="line-1128"></a>
<a name="line-1129"></a>  NB: this reasoning isn't water tight.
<a name="line-1130"></a>
<a name="line-1131"></a>Key lemma to make it watertight.
<a name="line-1132"></a>  Under the conditions of the Main Theorem,
<a name="line-1133"></a>  forall f st fw &gt;= f, a is not in S^k(f,t), for any k
<a name="line-1134"></a>
<a name="line-1135"></a>Also, consider roles more carefully. See Note [Flavours with roles].
<a name="line-1136"></a>
<a name="line-1137"></a>Completeness
<a name="line-1138"></a>~~~~~~~~~~~~~
<a name="line-1139"></a>K3: completeness.  (K3) is not necessary for the extended substitution
<a name="line-1140"></a>to be inert.  In fact K1 could be made stronger by saying
<a name="line-1141"></a>   ... then (not (fw &gt;= fs) or not (fs &gt;= fs))
<a name="line-1142"></a>But it's not enough for S to be inert; we also want completeness.
<a name="line-1143"></a>That is, we want to be able to solve all soluble wanted equalities.
<a name="line-1144"></a>Suppose we have
<a name="line-1145"></a>
<a name="line-1146"></a>   work-item   b -G-&gt; a
<a name="line-1147"></a>   inert-item  a -W-&gt; b
<a name="line-1148"></a>
<a name="line-1149"></a>Assuming (G &gt;= W) but not (W &gt;= W), this fulfills all the conditions,
<a name="line-1150"></a>so we could extend the inerts, thus:
<a name="line-1151"></a>
<a name="line-1152"></a>   inert-items   b -G-&gt; a
<a name="line-1153"></a>                 a -W-&gt; b
<a name="line-1154"></a>
<a name="line-1155"></a>But if we kicked-out the inert item, we'd get
<a name="line-1156"></a>
<a name="line-1157"></a>   work-item     a -W-&gt; b
<a name="line-1158"></a>   inert-item    b -G-&gt; a
<a name="line-1159"></a>
<a name="line-1160"></a>Then rewrite the work-item gives us (a -W-&gt; a), which is soluble via Refl.
<a name="line-1161"></a>So we add one more clause to the kick-out criteria
<a name="line-1162"></a>
<a name="line-1163"></a>Another way to understand (K3) is that we treat an inert item
<a name="line-1164"></a>        a -f-&gt; b
<a name="line-1165"></a>in the same way as
<a name="line-1166"></a>        b -f-&gt; a
<a name="line-1167"></a>So if we kick out one, we should kick out the other.  The orientation
<a name="line-1168"></a>is somewhat accidental.
<a name="line-1169"></a>
<a name="line-1170"></a>When considering roles, we also need the second clause (K3b). Consider
<a name="line-1171"></a>
<a name="line-1172"></a>  inert-item   a -W/R-&gt; b c
<a name="line-1173"></a>  work-item    c -G/N-&gt; a
<a name="line-1174"></a>
<a name="line-1175"></a>The work-item doesn't get rewritten by the inert, because (&gt;=) doesn't hold.
<a name="line-1176"></a>We've satisfied conditions (T1)-(T3) and (K1) and (K2). If all we had were
<a name="line-1177"></a>condition (K3a), then we would keep the inert around and add the work item.
<a name="line-1178"></a>But then, consider if we hit the following:
<a name="line-1179"></a>
<a name="line-1180"></a>  work-item2   b -G/N-&gt; Id
<a name="line-1181"></a>
<a name="line-1182"></a>where
<a name="line-1183"></a>
<a name="line-1184"></a>  newtype Id x = Id x
<a name="line-1185"></a>
<a name="line-1186"></a>For similar reasons, if we only had (K3a), we wouldn't kick the
<a name="line-1187"></a>representational inert out. And then, we'd miss solving the inert, which
<a name="line-1188"></a>now reduced to reflexivity. The solution here is to kick out representational
<a name="line-1189"></a>inerts whenever the tyvar of a work item is "exposed", where exposed means
<a name="line-1190"></a>not under some proper data-type constructor, like [] or Maybe. See
<a name="line-1191"></a>isTyVarExposed in TcType. This is encoded in (K3b).
<a name="line-1192"></a>
<a name="line-1193"></a>Note [Flavours with roles]
<a name="line-1194"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1195"></a>The system described in Note [The inert equalities] discusses an abstract
<a name="line-1196"></a>set of flavours. In GHC, flavours have two components: the flavour proper,
<a name="line-1197"></a>taken from {Wanted, Derived, Given}; and the equality relation (often called
<a name="line-1198"></a>role), taken from {NomEq, ReprEq}. When substituting w.r.t. the inert set,
<a name="line-1199"></a>as described in Note [The inert equalities], we must be careful to respect
<a name="line-1200"></a>roles. For example, if we have
<a name="line-1201"></a>
<a name="line-1202"></a>  inert set: a -G/R-&gt; Int
<a name="line-1203"></a>             b -G/R-&gt; Bool
<a name="line-1204"></a>
<a name="line-1205"></a>  type role T nominal representational
<a name="line-1206"></a>
<a name="line-1207"></a>and we wish to compute S(W/R, T a b), the correct answer is T a Bool, NOT
<a name="line-1208"></a>T Int Bool. The reason is that T's first parameter has a nominal role, and
<a name="line-1209"></a>thus rewriting a to Int in T a b is wrong. Indeed, this non-congruence of
<a name="line-1210"></a>subsitution means that the proof in Note [The inert equalities] may need
<a name="line-1211"></a>to be revisited, but we don't think that the end conclusion is wrong.
<a name="line-1212"></a>-}</span>
<a name="line-1213"></a>
<a name="line-1214"></a><a name="flattenTyVar"></a><span class='hs-definition'>flattenTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Xi</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span>
<a name="line-1215"></a><span class='hs-comment'>-- "Flattening" a type variable means to apply the substitution to it</span>
<a name="line-1216"></a><span class='hs-comment'>-- The substitution is actually the union of</span>
<a name="line-1217"></a><span class='hs-comment'>--     * the unifications that have taken place (either before the</span>
<a name="line-1218"></a><span class='hs-comment'>--       solver started, or in TcInteract.solveByUnification)</span>
<a name="line-1219"></a><span class='hs-comment'>--     * the CTyEqCans held in the inert set</span>
<a name="line-1220"></a><span class='hs-comment'>--</span>
<a name="line-1221"></a><span class='hs-comment'>-- Postcondition: co : xi ~ tv</span>
<a name="line-1222"></a><span class='hs-definition'>flattenTyVar</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tv</span>
<a name="line-1223"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flattenTyVarOuter</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tv</span>
<a name="line-1224"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_yes</span> <span class='hs-keyword'>of</span>
<a name="line-1225"></a>           <span class='hs-conid'>Left</span> <span class='hs-varid'>tv'</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- Done</span>
<a name="line-1226"></a>                       <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flattenTyVar1"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv'</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1227"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty'</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty'</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1228"></a>                    <span class='hs-keyword'>where</span>
<a name="line-1229"></a>                       <span class='hs-varid'>ty'</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv'</span>
<a name="line-1230"></a>
<a name="line-1231"></a>           <span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- Recurse</span>
<a name="line-1232"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>ty1</span>
<a name="line-1233"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"flattenTyVar3"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span>
<a name="line-1234"></a>                          <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty2</span><span class='hs-layout'>,</span> <span class='hs-varid'>co2</span> <span class='hs-varop'>`mkTcTransCo`</span> <span class='hs-varid'>co1</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1235"></a>       <span class='hs-layout'>}</span>
<a name="line-1236"></a>
<a name="line-1237"></a><a name="flattenTyVarOuter"></a><span class='hs-definition'>flattenTyVarOuter</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span>
<a name="line-1238"></a>                  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Either</span> <span class='hs-conid'>TyVar</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcType</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcCoercion</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1239"></a><span class='hs-comment'>-- Look up the tyvar in</span>
<a name="line-1240"></a><span class='hs-comment'>--   a) the internal MetaTyVar box</span>
<a name="line-1241"></a><span class='hs-comment'>--   b) the tyvar binds</span>
<a name="line-1242"></a><span class='hs-comment'>--   c) the inerts</span>
<a name="line-1243"></a><span class='hs-comment'>-- Return (Left tv')      if it is not found, tv' has a properly zonked kind</span>
<a name="line-1244"></a><span class='hs-comment'>--        (Right (ty, co) if found, with co :: ty ~ tv;</span>
<a name="line-1245"></a>
<a name="line-1246"></a><span class='hs-definition'>flattenTyVarOuter</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tv</span>
<a name="line-1247"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isTcTyVar</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>             <span class='hs-comment'>-- Happens when flatten under a (forall a. ty)</span>
<a name="line-1248"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>`liftM`</span> <span class='hs-varid'>flattenTyVarFinal</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tv</span>
<a name="line-1249"></a>          <span class='hs-comment'>-- So ty contains refernces to the non-TcTyVar a</span>
<a name="line-1250"></a>
<a name="line-1251"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1252"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar_maybe</span> <span class='hs-varid'>tv</span>
<a name="line-1253"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>mb_ty</span> <span class='hs-keyword'>of</span> <span class='hs-layout'>{</span>
<a name="line-1254"></a>           <span class='hs-conid'>Just</span> <span class='hs-varid'>ty</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Following filled tyvar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-1255"></a>                         <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>feRole</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>;</span>
<a name="line-1256"></a>           <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>-&gt;</span>
<a name="line-1257"></a>
<a name="line-1258"></a>    <span class='hs-comment'>-- Try in the inert equalities</span>
<a name="line-1259"></a>    <span class='hs-comment'>-- See Definition [Applying a generalised substitution]</span>
<a name="line-1260"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ieqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getInertEqs</span>
<a name="line-1261"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>lookupVarEnv</span> <span class='hs-varid'>ieqs</span> <span class='hs-varid'>tv</span> <span class='hs-keyword'>of</span>
<a name="line-1262"></a>           <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- If the first doesn't work,</span>
<a name="line-1263"></a>                         <span class='hs-comment'>-- the subsequent ones won't either</span>
<a name="line-1264"></a>             <span class='hs-keyglyph'>|</span> <span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-layout'>}</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ct</span>
<a name="line-1265"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ctEvFlavourRole</span> <span class='hs-varid'>ctev</span> <span class='hs-varop'>`eqCanRewriteFR`</span> <span class='hs-varid'>feFlavourRole</span> <span class='hs-varid'>fmode</span>
<a name="line-1266"></a>             <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Following inert tyvar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>equals</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span>
<a name="line-1267"></a>                    <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rewrite_co1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkTcSymCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvCoercion</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>)</span>
<a name="line-1268"></a>                          <span class='hs-varid'>rewrite_co</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvEqRel</span> <span class='hs-varid'>ctev</span><span class='hs-layout'>,</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-varid'>fmode</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-1269"></a>                            <span class='hs-layout'>(</span><span class='hs-conid'>ReprEq</span><span class='hs-layout'>,</span> <span class='hs-sel'>_rel</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ASSERT</span><span class='hs-layout'>(</span> <span class='hs-sel'>_rel</span> <span class='hs-varop'>==</span> <span class='hs-conid'>ReprEq</span> <span class='hs-layout'>)</span>
<a name="line-1270"></a>                                    <span class='hs-comment'>-- if this ASSERT fails, then</span>
<a name="line-1271"></a>                                    <span class='hs-comment'>-- eqCanRewriteFR answered incorrectly</span>
<a name="line-1272"></a>                                               <span class='hs-varid'>rewrite_co1</span>
<a name="line-1273"></a>                            <span class='hs-layout'>(</span><span class='hs-conid'>NomEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>rewrite_co1</span>
<a name="line-1274"></a>                            <span class='hs-layout'>(</span><span class='hs-conid'>NomEq</span><span class='hs-layout'>,</span> <span class='hs-conid'>ReprEq</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>mkTcSubCo</span> <span class='hs-varid'>rewrite_co1</span>
<a name="line-1275"></a>
<a name="line-1276"></a>                    <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-layout'>(</span><span class='hs-varid'>rhs_ty</span><span class='hs-layout'>,</span> <span class='hs-varid'>rewrite_co</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1277"></a>                    <span class='hs-comment'>-- NB: ct is Derived then fmode must be also, hence</span>
<a name="line-1278"></a>                    <span class='hs-comment'>-- we are not going to touch the returned coercion</span>
<a name="line-1279"></a>                    <span class='hs-comment'>-- so ctEvCoercion is fine.</span>
<a name="line-1280"></a>
<a name="line-1281"></a>           <span class='hs-sel'>_other</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Left</span> <span class='hs-varop'>`liftM`</span> <span class='hs-varid'>flattenTyVarFinal</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tv</span>
<a name="line-1282"></a>    <span class='hs-layout'>}</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1283"></a>
<a name="line-1284"></a><a name="flattenTyVarFinal"></a><span class='hs-definition'>flattenTyVarFinal</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TyVar</span>
<a name="line-1285"></a><span class='hs-definition'>flattenTyVarFinal</span> <span class='hs-varid'>fmode</span> <span class='hs-varid'>tv</span>
<a name="line-1286"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-comment'>-- Done, but make sure the kind is zonked</span>
<a name="line-1287"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>kind</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv</span>
<a name="line-1288"></a>             <span class='hs-varid'>kind_fmode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setFEMode</span> <span class='hs-varid'>fmode</span> <span class='hs-conid'>FM_SubstOnly</span>
<a name="line-1289"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>new_knd</span><span class='hs-layout'>,</span> <span class='hs-sel'>_kind_co</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatten_one</span> <span class='hs-varid'>kind_fmode</span> <span class='hs-varid'>kind</span>
<a name="line-1290"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>setVarType</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>new_knd</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1291"></a>
<a name="line-1292"></a><span class='hs-comment'>{-
<a name="line-1293"></a>Note [An alternative story for the inert substitution]
<a name="line-1294"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1295"></a>(This entire note is just background, left here in case we ever want
<a name="line-1296"></a> to return the the previousl state of affairs)
<a name="line-1297"></a>
<a name="line-1298"></a>We used (GHC 7.8) to have this story for the inert substitution inert_eqs
<a name="line-1299"></a>
<a name="line-1300"></a> * 'a' is not in fvs(ty)
<a name="line-1301"></a> * They are *inert* in the weaker sense that there is no infinite chain of
<a name="line-1302"></a>   (i1 `eqCanRewrite` i2), (i2 `eqCanRewrite` i3), etc
<a name="line-1303"></a>
<a name="line-1304"></a>This means that flattening must be recursive, but it does allow
<a name="line-1305"></a>  [G] a ~ [b]
<a name="line-1306"></a>  [G] b ~ Maybe c
<a name="line-1307"></a>
<a name="line-1308"></a>This avoids "saturating" the Givens, which can save a modest amount of work.
<a name="line-1309"></a>It is easy to implement, in TcInteract.kick_out, by only kicking out an inert
<a name="line-1310"></a>only if (a) the work item can rewrite the inert AND
<a name="line-1311"></a>        (b) the inert cannot rewrite the work item
<a name="line-1312"></a>
<a name="line-1313"></a>This is signifcantly harder to think about. It can save a LOT of work
<a name="line-1314"></a>in occurs-check cases, but we don't care about them much.  Trac #5837
<a name="line-1315"></a>is an example; all the constraints here are Givens
<a name="line-1316"></a>
<a name="line-1317"></a>             [G] a ~ TF (a,Int)
<a name="line-1318"></a>    --&gt;
<a name="line-1319"></a>    work     TF (a,Int) ~ fsk
<a name="line-1320"></a>    inert    fsk ~ a
<a name="line-1321"></a>
<a name="line-1322"></a>    ---&gt;
<a name="line-1323"></a>    work     fsk ~ (TF a, TF Int)
<a name="line-1324"></a>    inert    fsk ~ a
<a name="line-1325"></a>
<a name="line-1326"></a>    ---&gt;
<a name="line-1327"></a>    work     a ~ (TF a, TF Int)
<a name="line-1328"></a>    inert    fsk ~ a
<a name="line-1329"></a>
<a name="line-1330"></a>    ---&gt; (attempting to flatten (TF a) so that it does not mention a
<a name="line-1331"></a>    work     TF a ~ fsk2
<a name="line-1332"></a>    inert    a ~ (fsk2, TF Int)
<a name="line-1333"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1334"></a>
<a name="line-1335"></a>    ---&gt; (substitute for a)
<a name="line-1336"></a>    work     TF (fsk2, TF Int) ~ fsk2
<a name="line-1337"></a>    inert    a ~ (fsk2, TF Int)
<a name="line-1338"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1339"></a>
<a name="line-1340"></a>    ---&gt; (top-level reduction, re-orient)
<a name="line-1341"></a>    work     fsk2 ~ (TF fsk2, TF Int)
<a name="line-1342"></a>    inert    a ~ (fsk2, TF Int)
<a name="line-1343"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1344"></a>
<a name="line-1345"></a>    ---&gt; (attempt to flatten (TF fsk2) to get rid of fsk2
<a name="line-1346"></a>    work     TF fsk2 ~ fsk3
<a name="line-1347"></a>    work     fsk2 ~ (fsk3, TF Int)
<a name="line-1348"></a>    inert    a   ~ (fsk2, TF Int)
<a name="line-1349"></a>    inert    fsk ~ (fsk2, TF Int)
<a name="line-1350"></a>
<a name="line-1351"></a>    ---&gt;
<a name="line-1352"></a>    work     TF fsk2 ~ fsk3
<a name="line-1353"></a>    inert    fsk2 ~ (fsk3, TF Int)
<a name="line-1354"></a>    inert    a   ~ ((fsk3, TF Int), TF Int)
<a name="line-1355"></a>    inert    fsk ~ ((fsk3, TF Int), TF Int)
<a name="line-1356"></a>
<a name="line-1357"></a>Because the incoming given rewrites all the inert givens, we get more and
<a name="line-1358"></a>more duplication in the inert set.  But this really only happens in pathalogical
<a name="line-1359"></a>casee, so we don't care.
<a name="line-1360"></a>-}</span>
<a name="line-1361"></a>
<a name="line-1362"></a><a name="eqCanRewrite"></a><span class='hs-definition'>eqCanRewrite</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1363"></a><span class='hs-definition'>eqCanRewrite</span> <span class='hs-varid'>ev1</span> <span class='hs-varid'>ev2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvFlavourRole</span> <span class='hs-varid'>ev1</span> <span class='hs-varop'>`eqCanRewriteFR`</span> <span class='hs-varid'>ctEvFlavourRole</span> <span class='hs-varid'>ev2</span>
<a name="line-1364"></a>
<a name="line-1365"></a><a name="CtFlavourRole"></a><span class='hs-comment'>-- | Whether or not one 'Ct' can rewrite another is determined by its</span>
<a name="line-1366"></a><a name="CtFlavourRole"></a><span class='hs-comment'>-- flavour and its equality relation</span>
<a name="line-1367"></a><a name="CtFlavourRole"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>CtFlavourRole</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-conid'>CtFlavour</span><span class='hs-layout'>,</span> <span class='hs-conid'>EqRel</span><span class='hs-layout'>)</span>
<a name="line-1368"></a>
<a name="line-1369"></a><a name="ctEvFlavourRole"></a><span class='hs-comment'>-- | Extract the flavour and role from a 'CtEvidence'</span>
<a name="line-1370"></a><span class='hs-definition'>ctEvFlavourRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavourRole</span>
<a name="line-1371"></a><span class='hs-definition'>ctEvFlavourRole</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvFlavour</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>ctEvEqRel</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-1372"></a>
<a name="line-1373"></a><a name="ctFlavourRole"></a><span class='hs-comment'>-- | Extract the flavour and role from a 'Ct'</span>
<a name="line-1374"></a><span class='hs-definition'>ctFlavourRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavourRole</span>
<a name="line-1375"></a><span class='hs-definition'>ctFlavourRole</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvFlavourRole</span> <span class='hs-varop'>.</span> <span class='hs-varid'>cc_ev</span>
<a name="line-1376"></a>
<a name="line-1377"></a><a name="feFlavourRole"></a><span class='hs-comment'>-- | Extract the flavour and role from a 'FlattenEnv'</span>
<a name="line-1378"></a><span class='hs-definition'>feFlavourRole</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavourRole</span>
<a name="line-1379"></a><span class='hs-definition'>feFlavourRole</span> <span class='hs-layout'>(</span><span class='hs-conid'>FE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_flavour</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>flav</span><span class='hs-layout'>,</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1380"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>flav</span><span class='hs-layout'>,</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span>
<a name="line-1381"></a>
<a name="line-1382"></a><a name="eqCanRewriteFR"></a><span class='hs-definition'>eqCanRewriteFR</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtFlavourRole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavourRole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1383"></a><span class='hs-comment'>-- Very important function!</span>
<a name="line-1384"></a><span class='hs-comment'>-- See Note [eqCanRewrite]</span>
<a name="line-1385"></a><span class='hs-definition'>eqCanRewriteFR</span> <span class='hs-layout'>(</span><span class='hs-conid'>Given</span><span class='hs-layout'>,</span>   <span class='hs-conid'>NomEq</span><span class='hs-layout'>)</span>  <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span>       <span class='hs-keyword'>_</span><span class='hs-layout'>)</span>      <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1386"></a><span class='hs-definition'>eqCanRewriteFR</span> <span class='hs-layout'>(</span><span class='hs-conid'>Given</span><span class='hs-layout'>,</span>   <span class='hs-conid'>ReprEq</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span>       <span class='hs-conid'>ReprEq</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1387"></a><span class='hs-definition'>eqCanRewriteFR</span> <span class='hs-keyword'>_</span>                 <span class='hs-keyword'>_</span>                 <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1388"></a>
<a name="line-1389"></a><a name="canRewriteOrSame"></a><span class='hs-definition'>canRewriteOrSame</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1390"></a><span class='hs-comment'>-- See Note [canRewriteOrSame]</span>
<a name="line-1391"></a><span class='hs-definition'>canRewriteOrSame</span> <span class='hs-varid'>ev1</span> <span class='hs-varid'>ev2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev1</span> <span class='hs-varop'>`eqCanRewrite`</span> <span class='hs-varid'>ev2</span> <span class='hs-varop'>||</span>
<a name="line-1392"></a>                           <span class='hs-varid'>ctEvFlavourRole</span> <span class='hs-varid'>ev1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>ctEvFlavourRole</span> <span class='hs-varid'>ev2</span>
<a name="line-1393"></a>
<a name="line-1394"></a><a name="canRewriteOrSameFR"></a><span class='hs-definition'>canRewriteOrSameFR</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>CtFlavourRole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtFlavourRole</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1395"></a><span class='hs-definition'>canRewriteOrSameFR</span> <span class='hs-varid'>fr1</span> <span class='hs-varid'>fr2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fr1</span> <span class='hs-varop'>`eqCanRewriteFR`</span> <span class='hs-varid'>fr2</span> <span class='hs-varop'>||</span> <span class='hs-varid'>fr1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>fr2</span>
<a name="line-1396"></a>
<a name="line-1397"></a><span class='hs-comment'>{-
<a name="line-1398"></a>Note [eqCanRewrite]
<a name="line-1399"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-1400"></a>(eqCanRewrite ct1 ct2) holds if the constraint ct1 (a CTyEqCan of form
<a name="line-1401"></a>tv ~ ty) can be used to rewrite ct2.  It must satisfy the properties of
<a name="line-1402"></a>a can-rewrite relation, see Definition [Can-rewrite relation]
<a name="line-1403"></a>
<a name="line-1404"></a>At the moment we don't allow Wanteds to rewrite Wanteds, because that can give
<a name="line-1405"></a>rise to very confusing type error messages.  A good example is Trac #8450.
<a name="line-1406"></a>Here's another
<a name="line-1407"></a>   f :: a -&gt; Bool
<a name="line-1408"></a>   f x = ( [x,'c'], [x,True] ) `seq` True
<a name="line-1409"></a>Here we get
<a name="line-1410"></a>  [W] a ~ Char
<a name="line-1411"></a>  [W] a ~ Bool
<a name="line-1412"></a>but we do not want to complain about Bool ~ Char!
<a name="line-1413"></a>
<a name="line-1414"></a>Accordingly, we also don't let Deriveds rewrite Deriveds.
<a name="line-1415"></a>
<a name="line-1416"></a>With the solver handling Coercible constraints like equality constraints,
<a name="line-1417"></a>the rewrite conditions must take role into account, never allowing
<a name="line-1418"></a>a representational equality to rewrite a nominal one.
<a name="line-1419"></a>
<a name="line-1420"></a>Note [canRewriteOrSame]
<a name="line-1421"></a>~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1422"></a>canRewriteOrSame is similar but
<a name="line-1423"></a> * returns True for Wanted/Wanted.
<a name="line-1424"></a> * works for all kinds of constraints, not just CTyEqCans
<a name="line-1425"></a>See the call sites for explanations.
<a name="line-1426"></a>
<a name="line-1427"></a>************************************************************************
<a name="line-1428"></a>*                                                                      *
<a name="line-1429"></a>             Unflattening
<a name="line-1430"></a>*                                                                      *
<a name="line-1431"></a>************************************************************************
<a name="line-1432"></a>
<a name="line-1433"></a>An unflattening example:
<a name="line-1434"></a>    [W] F a ~ alpha
<a name="line-1435"></a>flattens to
<a name="line-1436"></a>    [W] F a ~ fmv   (CFunEqCan)
<a name="line-1437"></a>    [W] fmv ~ alpha (CTyEqCan)
<a name="line-1438"></a>We must solve both!
<a name="line-1439"></a>-}</span>
<a name="line-1440"></a>
<a name="line-1441"></a><a name="unflatten"></a><span class='hs-definition'>unflatten</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1442"></a><span class='hs-definition'>unflatten</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-varid'>funeqs</span>
<a name="line-1443"></a> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>dflags</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDynFlags</span>
<a name="line-1444"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tclvl</span>    <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcLevel</span>
<a name="line-1445"></a>
<a name="line-1446"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-varop'>$</span>
<a name="line-1447"></a>        <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Funeqs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprCts</span> <span class='hs-varid'>funeqs</span>
<a name="line-1448"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"Tv eqs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>pprCts</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-keyglyph'>]</span>
<a name="line-1449"></a>
<a name="line-1450"></a>         <span class='hs-comment'>-- Step 1: unflatten the CFunEqCans, except if that causes an occurs check</span>
<a name="line-1451"></a>         <span class='hs-comment'>-- See Note [Unflatten using funeqs first]</span>
<a name="line-1452"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>funeqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldrBagM</span> <span class='hs-layout'>(</span><span class='hs-varid'>unflatten_funeq</span> <span class='hs-varid'>dflags</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyCts</span> <span class='hs-varid'>funeqs</span>
<a name="line-1453"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening 1"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>funeqs</span><span class='hs-layout'>)</span>
<a name="line-1454"></a>
<a name="line-1455"></a>          <span class='hs-comment'>-- Step 2: unify the irreds, if possible</span>
<a name="line-1456"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tv_eqs</span>  <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldrBagM</span> <span class='hs-layout'>(</span><span class='hs-varid'>unflatten_eq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyCts</span> <span class='hs-varid'>tv_eqs</span>
<a name="line-1457"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening 2"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>tv_eqs</span><span class='hs-layout'>)</span>
<a name="line-1458"></a>
<a name="line-1459"></a>          <span class='hs-comment'>-- Step 3: fill any remaining fmvs with fresh unification variables</span>
<a name="line-1460"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>funeqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapBagM</span> <span class='hs-varid'>finalise_funeq</span> <span class='hs-varid'>funeqs</span>
<a name="line-1461"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening 3"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>funeqs</span><span class='hs-layout'>)</span>
<a name="line-1462"></a>
<a name="line-1463"></a>          <span class='hs-comment'>-- Step 4: remove any irreds that look like ty ~ ty</span>
<a name="line-1464"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>foldrBagM</span> <span class='hs-varid'>finalise_eq</span> <span class='hs-varid'>emptyCts</span> <span class='hs-varid'>tv_eqs</span>
<a name="line-1465"></a>
<a name="line-1466"></a>      <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_flat</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv_eqs</span> <span class='hs-varop'>`andCts`</span> <span class='hs-varid'>funeqs</span>
<a name="line-1467"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"Unflattening done"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>braces</span> <span class='hs-layout'>(</span><span class='hs-varid'>pprCts</span> <span class='hs-varid'>all_flat</span><span class='hs-layout'>)</span>
<a name="line-1468"></a>
<a name="line-1469"></a>      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>all_flat</span> <span class='hs-layout'>}</span>
<a name="line-1470"></a>  <span class='hs-keyword'>where</span>
<a name="line-1471"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1472"></a>    <span class='hs-varid'>unflatten_funeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1473"></a>    <span class='hs-varid'>unflatten_funeq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>ct</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_fun</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyargs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>xis</span>
<a name="line-1474"></a>                                         <span class='hs-layout'>,</span> <span class='hs-varid'>cc_fsk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-1475"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- fmv should be a flatten meta-tv; we now fix its final</span>
<a name="line-1476"></a>               <span class='hs-comment'>-- value, and then zonking will eliminate it</span>
<a name="line-1477"></a>             <span class='hs-varid'>filled</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryFill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>fmv</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyConApp</span> <span class='hs-varid'>tc</span> <span class='hs-varid'>xis</span><span class='hs-layout'>)</span> <span class='hs-varid'>ev</span>
<a name="line-1478"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-keyword'>if</span> <span class='hs-varid'>filled</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>rest</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1479"></a>
<a name="line-1480"></a>    <span class='hs-varid'>unflatten_funeq</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>other_ct</span> <span class='hs-keyword'>_</span>
<a name="line-1481"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"unflatten_funeq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>other_ct</span><span class='hs-layout'>)</span>
<a name="line-1482"></a>
<a name="line-1483"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1484"></a>    <span class='hs-varid'>finalise_funeq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Ct</span>
<a name="line-1485"></a>    <span class='hs-varid'>finalise_funeq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CFunEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_fsk</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1486"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>demoteUnfilledFmv</span> <span class='hs-varid'>fmv</span>
<a name="line-1487"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1488"></a>    <span class='hs-varid'>finalise_funeq</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"finalise_funeq"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-1489"></a>
<a name="line-1490"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1491"></a>    <span class='hs-varid'>unflatten_eq</span> <span class='hs-keyglyph'>::</span>  <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcLevel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1492"></a>    <span class='hs-varid'>unflatten_eq</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>ct</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-1493"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFmvTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-1494"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>lhs_elim</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tryFill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>ev</span>
<a name="line-1495"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>lhs_elim</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-keyword'>else</span>
<a name="line-1496"></a>        <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rhs_elim</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>try_fill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>rhs</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-1497"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>rhs_elim</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-keyword'>else</span>
<a name="line-1498"></a>             <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1499"></a>
<a name="line-1500"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1501"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>ct</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span>
<a name="line-1502"></a>
<a name="line-1503"></a>    <span class='hs-varid'>unflatten_eq</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>ct</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"unflatten_irred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-1504"></a>
<a name="line-1505"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1506"></a>    <span class='hs-varid'>finalise_eq</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Cts</span>
<a name="line-1507"></a>    <span class='hs-varid'>finalise_eq</span> <span class='hs-layout'>(</span><span class='hs-conid'>CTyEqCan</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cc_ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_tyvar</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv</span>
<a name="line-1508"></a>                          <span class='hs-layout'>,</span> <span class='hs-varid'>cc_rhs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>,</span> <span class='hs-varid'>cc_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>rest</span>
<a name="line-1509"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFmvTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-1510"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ty1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-1511"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>rhs</span>
<a name="line-1512"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>is_refl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>ty2</span>
<a name="line-1513"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>is_refl</span> <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1514"></a>                                  <span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvId</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-1515"></a>                                            <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-varop'>$</span>
<a name="line-1516"></a>                                             <span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>eqRelRole</span> <span class='hs-varid'>eq_rel</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs</span><span class='hs-layout'>)</span>
<a name="line-1517"></a>                                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>rest</span> <span class='hs-layout'>}</span>
<a name="line-1518"></a>                        <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1519"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1520"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkNonCanonical</span> <span class='hs-varid'>ev</span> <span class='hs-varop'>`consCts`</span> <span class='hs-varid'>rest</span><span class='hs-layout'>)</span>
<a name="line-1521"></a>
<a name="line-1522"></a>    <span class='hs-varid'>finalise_eq</span> <span class='hs-varid'>ct</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>pprPanic</span> <span class='hs-str'>"finalise_irred"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-1523"></a>
<a name="line-1524"></a>    <span class='hs-comment'>----------------</span>
<a name="line-1525"></a>    <span class='hs-varid'>try_fill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>ev</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1526"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty1</span>
<a name="line-1527"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>isTouchableOrFmv</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>tv1</span>
<a name="line-1528"></a>      <span class='hs-layout'>,</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>`isSubKind`</span> <span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>tv1</span>
<a name="line-1529"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tryFill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>ty2</span> <span class='hs-varid'>ev</span>
<a name="line-1530"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1531"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-1532"></a>
<a name="line-1533"></a><a name="tryFill"></a><span class='hs-definition'>tryFill</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>DynFlags</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>CtEvidence</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>
<a name="line-1534"></a><span class='hs-comment'>-- (tryFill tv rhs ev) sees if 'tv' is an un-filled MetaTv</span>
<a name="line-1535"></a><span class='hs-comment'>-- If so, and if tv does not appear in 'rhs', set tv := rhs</span>
<a name="line-1536"></a><span class='hs-comment'>-- bind the evidence (which should be a CtWanted) to Refl&lt;rhs&gt;</span>
<a name="line-1537"></a><span class='hs-comment'>-- and return True.  Otherwise return False</span>
<a name="line-1538"></a><span class='hs-definition'>tryFill</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs</span> <span class='hs-varid'>ev</span>
<a name="line-1539"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ASSERT2</span><span class='hs-layout'>(</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isGiven</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ev</span> <span class='hs-layout'>)</span>
<a name="line-1540"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>is_filled</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>isFilledMetaTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-1541"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>is_filled</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span> <span class='hs-keyword'>else</span>
<a name="line-1542"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkTcType</span> <span class='hs-varid'>rhs</span>
<a name="line-1543"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>occurCheckExpand</span> <span class='hs-varid'>dflags</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs'</span> <span class='hs-keyword'>of</span>
<a name="line-1544"></a>           <span class='hs-conid'>OC_OK</span> <span class='hs-varid'>rhs''</span>    <span class='hs-comment'>-- Normal case: fill the tyvar</span>
<a name="line-1545"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>when</span> <span class='hs-layout'>(</span><span class='hs-varid'>isWanted</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1546"></a>                     <span class='hs-varid'>setEvBind</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvId</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span>
<a name="line-1547"></a>                               <span class='hs-layout'>(</span><span class='hs-conid'>EvCoercion</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcReflCo</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvRole</span> <span class='hs-varid'>ev</span><span class='hs-layout'>)</span> <span class='hs-varid'>rhs''</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1548"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-varid'>rhs''</span>
<a name="line-1549"></a>                   <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-1550"></a>
<a name="line-1551"></a>           <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span>  <span class='hs-comment'>-- Occurs check</span>
<a name="line-1552"></a>                 <span class='hs-varid'>return</span> <span class='hs-conid'>False</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1553"></a>
<a name="line-1554"></a><span class='hs-comment'>{-
<a name="line-1555"></a>Note [Unflatten using funeqs first]
<a name="line-1556"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1557"></a>    [W] G a ~ Int
<a name="line-1558"></a>    [W] F (G a) ~ G a
<a name="line-1559"></a>
<a name="line-1560"></a>do not want to end up with
<a name="line-1561"></a>    [W} F Int ~ Int
<a name="line-1562"></a>because that might actually hold!  Better to end up with the two above
<a name="line-1563"></a>unsolved constraints.  The flat form will be
<a name="line-1564"></a>
<a name="line-1565"></a>    G a ~ fmv1     (CFunEqCan)
<a name="line-1566"></a>    F fmv1 ~ fmv2  (CFunEqCan)
<a name="line-1567"></a>    fmv1 ~ Int     (CTyEqCan)
<a name="line-1568"></a>    fmv1 ~ fmv2    (CTyEqCan)
<a name="line-1569"></a>
<a name="line-1570"></a>Flatten using the fun-eqs first.
<a name="line-1571"></a>-}</span>
<a name="line-1572"></a>
<a name="line-1573"></a><a name="setFEEqRel"></a><span class='hs-comment'>-- | Change the 'EqRel' in a 'FlattenEnv'. Avoids allocating a</span>
<a name="line-1574"></a><span class='hs-comment'>-- new 'FlattenEnv' where possible.</span>
<a name="line-1575"></a><span class='hs-definition'>setFEEqRel</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>EqRel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlattenEnv</span>
<a name="line-1576"></a><span class='hs-definition'>setFEEqRel</span> <span class='hs-varid'>fmode</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>FE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_eq_rel</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_eq_rel</span>
<a name="line-1577"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>old_eq_rel</span> <span class='hs-varop'>==</span> <span class='hs-varid'>new_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmode</span>
<a name="line-1578"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_eq_rel</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_eq_rel</span> <span class='hs-layout'>}</span>
<a name="line-1579"></a>
<a name="line-1580"></a><a name="setFEMode"></a><span class='hs-comment'>-- | Change the 'FlattenMode' in a 'FlattenEnv'. Avoids allocating</span>
<a name="line-1581"></a><span class='hs-comment'>-- a new 'FlattenEnv' where possible.</span>
<a name="line-1582"></a><span class='hs-definition'>setFEMode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>FlattenEnv</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlattenMode</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>FlattenEnv</span>
<a name="line-1583"></a><span class='hs-definition'>setFEMode</span> <span class='hs-varid'>fmode</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>FE</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>old_mode</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_mode</span>
<a name="line-1584"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>old_mode</span> <span class='hs-varop'>`eq`</span> <span class='hs-varid'>new_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmode</span>
<a name="line-1585"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>            <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fmode</span> <span class='hs-layout'>{</span> <span class='hs-varid'>fe_mode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new_mode</span> <span class='hs-layout'>}</span>
<a name="line-1586"></a>  <span class='hs-keyword'>where</span>
<a name="line-1587"></a>    <span class='hs-conid'>FM_FlattenAll</span>   <span class='hs-varop'>`eq`</span> <span class='hs-conid'>FM_FlattenAll</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1588"></a>    <span class='hs-conid'>FM_SubstOnly</span>    <span class='hs-varop'>`eq`</span> <span class='hs-conid'>FM_SubstOnly</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1589"></a>    <span class='hs-conid'>FM_Avoid</span> <span class='hs-varid'>tv1</span> <span class='hs-varid'>b1</span> <span class='hs-varop'>`eq`</span> <span class='hs-conid'>FM_Avoid</span> <span class='hs-varid'>tv2</span> <span class='hs-varid'>b2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>tv2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b1</span> <span class='hs-varop'>==</span> <span class='hs-varid'>b2</span>
<a name="line-1590"></a>    <span class='hs-keyword'>_</span>               <span class='hs-varop'>`eq`</span> <span class='hs-keyword'>_</span>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
</pre></body>
</html>
