<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>typecheck/TcSimplify.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-2"></a>
<a name="line-3"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>TcSimplify</span><span class='hs-layout'>(</span>
<a name="line-4"></a>       <span class='hs-varid'>simplifyInfer</span><span class='hs-layout'>,</span>
<a name="line-5"></a>       <span class='hs-varid'>quantifyPred</span><span class='hs-layout'>,</span> <span class='hs-varid'>growThetaTyVars</span><span class='hs-layout'>,</span>
<a name="line-6"></a>       <span class='hs-varid'>simplifyAmbiguityCheck</span><span class='hs-layout'>,</span>
<a name="line-7"></a>       <span class='hs-varid'>simplifyDefault</span><span class='hs-layout'>,</span>
<a name="line-8"></a>       <span class='hs-varid'>simplifyRule</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyTop</span><span class='hs-layout'>,</span> <span class='hs-varid'>simplifyInteractive</span><span class='hs-layout'>,</span>
<a name="line-9"></a>       <span class='hs-varid'>solveWantedsTcM</span>
<a name="line-10"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-11"></a>
<a name="line-12"></a><span class='hs-cpp'>#include "HsVersions.h"</span>
<a name="line-13"></a>
<a name="line-14"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnTypes</span>
<a name="line-15"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcRnMonad</span>
<a name="line-16"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcErrors</span>
<a name="line-17"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcMType</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TcM</span>
<a name="line-18"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcType</span>
<a name="line-19"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcSMonad</span> <span class='hs-keyword'>as</span> <span class='hs-conid'>TcS</span>
<a name="line-20"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcInteract</span>
<a name="line-21"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Kind</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>isKind</span><span class='hs-layout'>,</span> <span class='hs-varid'>isSubKind</span><span class='hs-layout'>,</span> <span class='hs-varid'>defaultKind_maybe</span> <span class='hs-layout'>)</span>
<a name="line-22"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Inst</span>
<a name="line-23"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Type</span>     <span class='hs-layout'>(</span> <span class='hs-varid'>classifyPredType</span><span class='hs-layout'>,</span> <span class='hs-varid'>isIPClass</span><span class='hs-layout'>,</span> <span class='hs-conid'>PredTree</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span>
<a name="line-24"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>getClassPredTys_maybe</span><span class='hs-layout'>,</span> <span class='hs-conid'>EqRel</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-25"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TyCon</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-layout'>)</span>
<a name="line-26"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>    <span class='hs-layout'>(</span> <span class='hs-conid'>Class</span> <span class='hs-layout'>)</span>
<a name="line-27"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Id</span>       <span class='hs-layout'>(</span> <span class='hs-varid'>idType</span> <span class='hs-layout'>)</span>
<a name="line-28"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Var</span>
<a name="line-29"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Unique</span>
<a name="line-30"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>VarSet</span>
<a name="line-31"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TcEvidence</span>
<a name="line-32"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Name</span>
<a name="line-33"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Bag</span>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>ListSetOps</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Util</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelInfo</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>PrelNames</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Monad</span>    <span class='hs-layout'>(</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>)</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>DynFlags</span>         <span class='hs-layout'>(</span> <span class='hs-conid'>ExtensionFlag</span><span class='hs-layout'>(</span> <span class='hs-conid'>Opt_AllowAmbiguousTypes</span> <span class='hs-layout'>)</span> <span class='hs-layout'>)</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Class</span>            <span class='hs-layout'>(</span> <span class='hs-varid'>classKey</span> <span class='hs-layout'>)</span>
<a name="line-41"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>BasicTypes</span>       <span class='hs-layout'>(</span> <span class='hs-conid'>RuleName</span> <span class='hs-layout'>)</span>
<a name="line-42"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Outputable</span>
<a name="line-43"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>FastString</span>
<a name="line-44"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>TrieMap</span> <span class='hs-conid'>()</span> <span class='hs-comment'>-- DV: for now</span>
<a name="line-45"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span><span class='hs-layout'>(</span> <span class='hs-varid'>partition</span> <span class='hs-layout'>)</span>
<a name="line-46"></a>
<a name="line-47"></a><span class='hs-comment'>{-
<a name="line-48"></a>*********************************************************************************
<a name="line-49"></a>*                                                                               *
<a name="line-50"></a>*                           External interface                                  *
<a name="line-51"></a>*                                                                               *
<a name="line-52"></a>*********************************************************************************
<a name="line-53"></a>-}</span>
<a name="line-54"></a>
<a name="line-55"></a><a name="simplifyTop"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-56"></a><span class='hs-comment'>-- Simplify top-level constraints</span>
<a name="line-57"></a><span class='hs-comment'>-- Usually these will be implications,</span>
<a name="line-58"></a><span class='hs-comment'>-- but when there is nothing to quantify we don't wrap</span>
<a name="line-59"></a><span class='hs-comment'>-- in a degenerate implication, so we do that here instead</span>
<a name="line-60"></a><span class='hs-definition'>simplifyTop</span> <span class='hs-varid'>wanteds</span>
<a name="line-61"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyTop {"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wanted = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-62"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>newTcEvBinds</span>
<a name="line-63"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_final_wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcMWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>simpl_top</span>
<a name="line-64"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>binds1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcRnMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>getTcEvBinds</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-65"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"End simplifyTop }"</span> <span class='hs-varid'>empty</span>
<a name="line-66"></a>
<a name="line-67"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved {"</span> <span class='hs-varid'>empty</span>
<a name="line-68"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>binds2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>zonked_final_wc</span>
<a name="line-69"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved }"</span> <span class='hs-varid'>empty</span>
<a name="line-70"></a>
<a name="line-71"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>binds1</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>binds2</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-72"></a>
<a name="line-73"></a><a name="simpl_top"></a><span class='hs-definition'>simpl_top</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-74"></a>    <span class='hs-comment'>-- See Note [Top-level Defaulting Plan]</span>
<a name="line-75"></a><span class='hs-definition'>simpl_top</span> <span class='hs-varid'>wanteds</span>
<a name="line-76"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_first_go</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWantedsAndDrop</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-77"></a>                            <span class='hs-comment'>-- This is where the main work happens</span>
<a name="line-78"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>try_tyvar_defaulting</span> <span class='hs-varid'>wc_first_go</span> <span class='hs-layout'>}</span>
<a name="line-79"></a>  <span class='hs-keyword'>where</span>
<a name="line-80"></a>    <span class='hs-varid'>try_tyvar_defaulting</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-81"></a>    <span class='hs-varid'>try_tyvar_defaulting</span> <span class='hs-varid'>wc</span>
<a name="line-82"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wc</span>
<a name="line-83"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span>
<a name="line-84"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-85"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>free_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>zonkTyVarsAndFV</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfWC</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-86"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>meta_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>varSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>filterVarSet</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>free_tvs</span><span class='hs-layout'>)</span>
<a name="line-87"></a>                   <span class='hs-comment'>-- zonkTyVarsAndFV: the wc_first_go is not yet zonked</span>
<a name="line-88"></a>                   <span class='hs-comment'>-- filter isMetaTyVar: we might have runtime-skolems in GHCi,</span>
<a name="line-89"></a>                   <span class='hs-comment'>-- and we definitely don't want to try to assign to those!</span>
<a name="line-90"></a>
<a name="line-91"></a>           <span class='hs-layout'>;</span> <span class='hs-varid'>meta_tvs'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-varid'>defaultTyVar</span> <span class='hs-varid'>meta_tvs</span>   <span class='hs-comment'>-- Has unification side effects</span>
<a name="line-92"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>meta_tvs'</span> <span class='hs-varop'>==</span> <span class='hs-varid'>meta_tvs</span>   <span class='hs-comment'>-- No defaulting took place;</span>
<a name="line-93"></a>                                        <span class='hs-comment'>-- (defaulting returns fresh vars)</span>
<a name="line-94"></a>             <span class='hs-keyword'>then</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc</span>
<a name="line-95"></a>             <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_residual</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWantedsAndDrop</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-96"></a>                            <span class='hs-comment'>-- See Note [Must simplify after defaulting]</span>
<a name="line-97"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc_residual</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-98"></a>
<a name="line-99"></a>    <span class='hs-varid'>try_class_defaulting</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-100"></a>    <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc</span>
<a name="line-101"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wc</span>
<a name="line-102"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span>
<a name="line-103"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>  <span class='hs-comment'>-- See Note [When to do type-class defaulting]</span>
<a name="line-104"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>something_happened</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>applyDefaultingRules</span> <span class='hs-layout'>(</span><span class='hs-varid'>approximateWC</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-105"></a>                                   <span class='hs-comment'>-- See Note [Top-level Defaulting Plan]</span>
<a name="line-106"></a>           <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>something_happened</span>
<a name="line-107"></a>             <span class='hs-keyword'>then</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_residual</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestTcS</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWantedsAndDrop</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-108"></a>                     <span class='hs-layout'>;</span> <span class='hs-varid'>try_class_defaulting</span> <span class='hs-varid'>wc_residual</span> <span class='hs-layout'>}</span>
<a name="line-109"></a>             <span class='hs-keyword'>else</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wc</span> <span class='hs-layout'>}</span>
<a name="line-110"></a>
<a name="line-111"></a><span class='hs-comment'>{-
<a name="line-112"></a>Note [When to do type-class defaulting]
<a name="line-113"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-114"></a>In GHC 7.6 and 7.8.2, we did type-class defaulting only if insolubleWC
<a name="line-115"></a>was false, on the grounds that defaulting can't help solve insoluble
<a name="line-116"></a>constraints.  But if we *don't* do defaulting we may report a whole
<a name="line-117"></a>lot of errors that would be solved by defaulting; these errors are
<a name="line-118"></a>quite spurious because fixing the single insoluble error means that
<a name="line-119"></a>defaulting happens again, which makes all the other errors go away.
<a name="line-120"></a>This is jolly confusing: Trac #9033.
<a name="line-121"></a>
<a name="line-122"></a>So it seems better to always do type-class defaulting.
<a name="line-123"></a>
<a name="line-124"></a>However, always doing defaulting does mean that we'll do it in
<a name="line-125"></a>situations like this (Trac #5934):
<a name="line-126"></a>   run :: (forall s. GenST s) -&gt; Int
<a name="line-127"></a>   run = fromInteger 0
<a name="line-128"></a>We don't unify the return type of fromInteger with the given function
<a name="line-129"></a>type, because the latter involves foralls.  So we're left with
<a name="line-130"></a>    (Num alpha, alpha ~ (forall s. GenST s) -&gt; Int)
<a name="line-131"></a>Now we do defaulting, get alpha := Integer, and report that we can't
<a name="line-132"></a>match Integer with (forall s. GenST s) -&gt; Int.  That's not totally
<a name="line-133"></a>stupid, but perhaps a little strange.
<a name="line-134"></a>
<a name="line-135"></a>Another potential alternative would be to suppress *all* non-insoluble
<a name="line-136"></a>errors if there are *any* insoluble errors, anywhere, but that seems
<a name="line-137"></a>too drastic.
<a name="line-138"></a>
<a name="line-139"></a>Note [Must simplify after defaulting]
<a name="line-140"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-141"></a>We may have a deeply buried constraint
<a name="line-142"></a>    (t:*) ~ (a:Open)
<a name="line-143"></a>which we couldn't solve because of the kind incompatibility, and 'a' is free.
<a name="line-144"></a>Then when we default 'a' we can solve the constraint.  And we want to do
<a name="line-145"></a>that before starting in on type classes.  We MUST do it before reporting
<a name="line-146"></a>errors, because it isn't an error!  Trac #7967 was due to this.
<a name="line-147"></a>
<a name="line-148"></a>Note [Top-level Defaulting Plan]
<a name="line-149"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-150"></a>We have considered two design choices for where/when to apply defaulting.
<a name="line-151"></a>   (i) Do it in SimplCheck mode only /whenever/ you try to solve some
<a name="line-152"></a>       simple constraints, maybe deep inside the context of implications.
<a name="line-153"></a>       This used to be the case in GHC 7.4.1.
<a name="line-154"></a>   (ii) Do it in a tight loop at simplifyTop, once all other constraint has
<a name="line-155"></a>        finished. This is the current story.
<a name="line-156"></a>
<a name="line-157"></a>Option (i) had many disadvantages:
<a name="line-158"></a>   a) First it was deep inside the actual solver,
<a name="line-159"></a>   b) Second it was dependent on the context (Infer a type signature,
<a name="line-160"></a>      or Check a type signature, or Interactive) since we did not want
<a name="line-161"></a>      to always start defaulting when inferring (though there is an exception to
<a name="line-162"></a>      this see Note [Default while Inferring])
<a name="line-163"></a>   c) It plainly did not work. Consider typecheck/should_compile/DfltProb2.hs:
<a name="line-164"></a>          f :: Int -&gt; Bool
<a name="line-165"></a>          f x = const True (\y -&gt; let w :: a -&gt; a
<a name="line-166"></a>                                      w a = const a (y+1)
<a name="line-167"></a>                                  in w y)
<a name="line-168"></a>      We will get an implication constraint (for beta the type of y):
<a name="line-169"></a>               [untch=beta] forall a. 0 =&gt; Num beta
<a name="line-170"></a>      which we really cannot default /while solving/ the implication, since beta is
<a name="line-171"></a>      untouchable.
<a name="line-172"></a>
<a name="line-173"></a>Instead our new defaulting story is to pull defaulting out of the solver loop and
<a name="line-174"></a>go with option (i), implemented at SimplifyTop. Namely:
<a name="line-175"></a>     - First have a go at solving the residual constraint of the whole program
<a name="line-176"></a>     - Try to approximate it with a simple constraint
<a name="line-177"></a>     - Figure out derived defaulting equations for that simple constraint
<a name="line-178"></a>     - Go round the loop again if you did manage to get some equations
<a name="line-179"></a>
<a name="line-180"></a>Now, that has to do with class defaulting. However there exists type variable /kind/
<a name="line-181"></a>defaulting. Again this is done at the top-level and the plan is:
<a name="line-182"></a>     - At the top-level, once you had a go at solving the constraint, do
<a name="line-183"></a>       figure out /all/ the touchable unification variables of the wanted constraints.
<a name="line-184"></a>     - Apply defaulting to their kinds
<a name="line-185"></a>
<a name="line-186"></a>More details in Note [DefaultTyVar].
<a name="line-187"></a>-}</span>
<a name="line-188"></a>
<a name="line-189"></a><a name="simplifyAmbiguityCheck"></a><span class='hs-comment'>------------------</span>
<a name="line-190"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Type</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>
<a name="line-191"></a><span class='hs-definition'>simplifyAmbiguityCheck</span> <span class='hs-varid'>ty</span> <span class='hs-varid'>wanteds</span>
<a name="line-192"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyAmbiguityCheck {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-str'>"type = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wanted = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-193"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>newTcEvBinds</span>
<a name="line-194"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_final_wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcMWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>simpl_top</span>
<a name="line-195"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"End simplifyAmbiguityCheck }"</span> <span class='hs-varid'>empty</span>
<a name="line-196"></a>
<a name="line-197"></a>       <span class='hs-comment'>-- Normally report all errors; but with -XAllowAmbiguousTypes</span>
<a name="line-198"></a>       <span class='hs-comment'>-- report only insoluble ones, since they represent genuinely</span>
<a name="line-199"></a>       <span class='hs-comment'>-- inaccessible code</span>
<a name="line-200"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>allow_ambiguous</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>xoptM</span> <span class='hs-conid'>Opt_AllowAmbiguousTypes</span>
<a name="line-201"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved(ambig) {"</span> <span class='hs-varid'>empty</span>
<a name="line-202"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>unless</span> <span class='hs-layout'>(</span><span class='hs-varid'>allow_ambiguous</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>zonked_final_wc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-203"></a>                <span class='hs-layout'>(</span><span class='hs-varid'>discardResult</span> <span class='hs-layout'>(</span><span class='hs-varid'>reportUnsolved</span> <span class='hs-varid'>zonked_final_wc</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-204"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved(ambig) }"</span> <span class='hs-varid'>empty</span>
<a name="line-205"></a>
<a name="line-206"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-207"></a>
<a name="line-208"></a><a name="simplifyInteractive"></a><span class='hs-comment'>------------------</span>
<a name="line-209"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-210"></a><span class='hs-definition'>simplifyInteractive</span> <span class='hs-varid'>wanteds</span>
<a name="line-211"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInteractive"</span> <span class='hs-varid'>empty</span> <span class='hs-varop'>&gt;&gt;</span>
<a name="line-212"></a>    <span class='hs-varid'>simplifyTop</span> <span class='hs-varid'>wanteds</span>
<a name="line-213"></a>
<a name="line-214"></a><a name="simplifyDefault"></a><span class='hs-comment'>------------------</span>
<a name="line-215"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ThetaType</span>    <span class='hs-comment'>-- Wanted; has no type variables in it</span>
<a name="line-216"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>()</span>       <span class='hs-comment'>-- Succeeds iff the constraint is soluble</span>
<a name="line-217"></a><span class='hs-definition'>simplifyDefault</span> <span class='hs-varid'>theta</span>
<a name="line-218"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInteractive"</span> <span class='hs-varid'>empty</span>
<a name="line-219"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>newSimpleWanteds</span> <span class='hs-conid'>DefaultOrigin</span> <span class='hs-varid'>theta</span>
<a name="line-220"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>unsolved</span><span class='hs-layout'>,</span> <span class='hs-sel'>_binds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkSimpleWC</span> <span class='hs-varid'>wanted</span><span class='hs-layout'>)</span>
<a name="line-221"></a>
<a name="line-222"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved {"</span> <span class='hs-varid'>empty</span>
<a name="line-223"></a>       <span class='hs-comment'>-- See Note [Deferring coercion errors to runtime]</span>
<a name="line-224"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>reportAllUnsolved</span> <span class='hs-varid'>unsolved</span>
<a name="line-225"></a>         <span class='hs-comment'>-- Postcondition of solveWantedsTcM is that returned</span>
<a name="line-226"></a>         <span class='hs-comment'>-- constraints are zonked. So Precondition of reportUnsolved</span>
<a name="line-227"></a>         <span class='hs-comment'>-- is true.</span>
<a name="line-228"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"reportUnsolved }"</span> <span class='hs-varid'>empty</span>
<a name="line-229"></a>
<a name="line-230"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span> <span class='hs-layout'>}</span>
<a name="line-231"></a>
<a name="line-232"></a><span class='hs-comment'>{-
<a name="line-233"></a>*********************************************************************************
<a name="line-234"></a>*                                                                                 *
<a name="line-235"></a>*                            Inference
<a name="line-236"></a>*                                                                                 *
<a name="line-237"></a>***********************************************************************************
<a name="line-238"></a>
<a name="line-239"></a>Note [Inferring the type of a let-bound variable]
<a name="line-240"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-241"></a>Consider
<a name="line-242"></a>   f x = rhs
<a name="line-243"></a>
<a name="line-244"></a>To infer f's type we do the following:
<a name="line-245"></a> * Gather the constraints for the RHS with ambient level *one more than*
<a name="line-246"></a>   the current one.  This is done by the call
<a name="line-247"></a>        captureConstraints (captureTcLevel (tcMonoBinds...))
<a name="line-248"></a>   in TcBinds.tcPolyInfer
<a name="line-249"></a>
<a name="line-250"></a> * Call simplifyInfer to simplify the constraints and decide what to
<a name="line-251"></a>   quantify over. We pass in the level used for the RHS constraints,
<a name="line-252"></a>   here called rhs_tclvl.
<a name="line-253"></a>
<a name="line-254"></a>This ensures that the implication constraint we generate, if any,
<a name="line-255"></a>has a strictly-increased level compared to the ambient level outside
<a name="line-256"></a>the let binding.
<a name="line-257"></a>-}</span>
<a name="line-258"></a>
<a name="line-259"></a><a name="simplifyInfer"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcLevel</span>          <span class='hs-comment'>-- Used when generating the constraints</span>
<a name="line-260"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>                  <span class='hs-comment'>-- Apply monomorphism restriction</span>
<a name="line-261"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Name</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTauType</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>   <span class='hs-comment'>-- Variables to be generalised,</span>
<a name="line-262"></a>                                       <span class='hs-comment'>-- and their tau-types</span>
<a name="line-263"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-264"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>    <span class='hs-comment'>-- Quantify over these type variables</span>
<a name="line-265"></a>                      <span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- ... and these constraints</span>
<a name="line-266"></a>                      <span class='hs-conid'>Bool</span><span class='hs-layout'>,</span>         <span class='hs-comment'>-- The monomorphism restriction did something</span>
<a name="line-267"></a>                                    <span class='hs-comment'>--   so the results type is not as general as</span>
<a name="line-268"></a>                                    <span class='hs-comment'>--   it could be</span>
<a name="line-269"></a>                      <span class='hs-conid'>TcEvBinds</span><span class='hs-layout'>)</span>    <span class='hs-comment'>-- ... binding these evidence variables</span>
<a name="line-270"></a><span class='hs-definition'>simplifyInfer</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varid'>apply_mr</span> <span class='hs-varid'>name_taus</span> <span class='hs-varid'>wanteds</span>
<a name="line-271"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>wanteds</span>
<a name="line-272"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-273"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtkvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>quantifyTyVars</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>name_taus</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-274"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInfer: empty WC"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>name_taus</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtkvs</span><span class='hs-layout'>)</span>
<a name="line-275"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>qtkvs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyTcEvBinds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-276"></a>
<a name="line-277"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-278"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyInfer {"</span>  <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-279"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"binds ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>name_taus</span>
<a name="line-280"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"rhs_tclvl ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>rhs_tclvl</span>
<a name="line-281"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"apply_mr ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>apply_mr</span>
<a name="line-282"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"(unzonked) wanted ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-283"></a>             <span class='hs-keyglyph'>]</span>
<a name="line-284"></a>
<a name="line-285"></a>              <span class='hs-comment'>-- Historical note: Before step 2 we used to have a</span>
<a name="line-286"></a>              <span class='hs-comment'>-- HORRIBLE HACK described in Note [Avoid unecessary</span>
<a name="line-287"></a>              <span class='hs-comment'>-- constraint simplification] but, as described in Trac</span>
<a name="line-288"></a>              <span class='hs-comment'>-- #4361, we have taken in out now.  That's why we start</span>
<a name="line-289"></a>              <span class='hs-comment'>-- with step 2!</span>
<a name="line-290"></a>
<a name="line-291"></a>              <span class='hs-comment'>-- Step 2) First try full-blown solving</span>
<a name="line-292"></a>
<a name="line-293"></a>              <span class='hs-comment'>-- NB: we must gather up all the bindings from doing</span>
<a name="line-294"></a>              <span class='hs-comment'>-- this solving; hence (runTcSWithEvBinds ev_binds_var).</span>
<a name="line-295"></a>              <span class='hs-comment'>-- And note that since there are nested implications,</span>
<a name="line-296"></a>              <span class='hs-comment'>-- calling solveWanteds will side-effect their evidence</span>
<a name="line-297"></a>              <span class='hs-comment'>-- bindings, so we can't just revert to the input</span>
<a name="line-298"></a>              <span class='hs-comment'>-- constraint.</span>
<a name="line-299"></a>
<a name="line-300"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>newTcEvBinds</span>
<a name="line-301"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setTcLevel</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varop'>$</span>
<a name="line-302"></a>                                           <span class='hs-varid'>runTcSWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-303"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-304"></a>
<a name="line-305"></a>              <span class='hs-comment'>-- Step 4) Candidates for quantification are an approximation of wanted_transformed</span>
<a name="line-306"></a>              <span class='hs-comment'>-- NB: Already the fixpoint of any unifications that may have happened</span>
<a name="line-307"></a>              <span class='hs-comment'>-- NB: We do not do any defaulting when inferring a type, this can lead</span>
<a name="line-308"></a>              <span class='hs-comment'>-- to less polymorphic types, see Note [Default while Inferring]</span>
<a name="line-309"></a>
<a name="line-310"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tc_lcl_env</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcRnMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>getLclEnv</span>
<a name="line-311"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>null_ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>newTcEvBinds</span>
<a name="line-312"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>wanted_transformed</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropDerivedWC</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-313"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>quant_pred_candidates</span>   <span class='hs-comment'>-- Fully zonked</span>
<a name="line-314"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>wanted_transformed_incl_derivs</span>
<a name="line-315"></a>              <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-conid'>[]</span>   <span class='hs-comment'>-- See Note [Quantification with errors]</span>
<a name="line-316"></a>                               <span class='hs-comment'>-- NB: must include derived errors in this test,</span>
<a name="line-317"></a>                               <span class='hs-comment'>--     hence "incl_derivs"</span>
<a name="line-318"></a>
<a name="line-319"></a>              <span class='hs-keyword'>else</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>quant_cand</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>approximateWC</span> <span class='hs-varid'>wanted_transformed</span>
<a name="line-320"></a>                            <span class='hs-varid'>meta_tvs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>varSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfCts</span> <span class='hs-varid'>quant_cand</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-321"></a>                      <span class='hs-layout'>;</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-322"></a>                            <span class='hs-comment'>-- Miminise quant_cand.  We are not interested in any evidence</span>
<a name="line-323"></a>                            <span class='hs-comment'>-- produced, because we are going to simplify wanted_transformed</span>
<a name="line-324"></a>                            <span class='hs-comment'>-- again later. All we want here is the predicates over which to</span>
<a name="line-325"></a>                            <span class='hs-comment'>-- quantify.</span>
<a name="line-326"></a>                            <span class='hs-comment'>--</span>
<a name="line-327"></a>                            <span class='hs-comment'>-- If any meta-tyvar unifications take place (unlikely), we'll</span>
<a name="line-328"></a>                            <span class='hs-comment'>-- pick that up later.</span>
<a name="line-329"></a>
<a name="line-330"></a>
<a name="line-331"></a>                      <span class='hs-layout'>;</span> <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span> <span class='hs-layout'>}</span>
<a name="line-332"></a>                           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>setTcLevel</span> <span class='hs-varid'>rhs_tclvl</span>                <span class='hs-varop'>$</span>
<a name="line-333"></a>                              <span class='hs-varid'>runTcSWithEvBinds</span> <span class='hs-varid'>null_ev_binds_var</span> <span class='hs-varop'>$</span>
<a name="line-334"></a>                              <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>promoteAndDefaultTyVar</span> <span class='hs-varid'>rhs_tclvl</span> <span class='hs-varid'>gbl_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>meta_tvs</span>
<a name="line-335"></a>                                     <span class='hs-comment'>-- See Note [Promote _and_ default when inferring]</span>
<a name="line-336"></a>                                 <span class='hs-layout'>;</span> <span class='hs-varid'>solveSimpleWanteds</span> <span class='hs-varid'>quant_cand</span> <span class='hs-layout'>}</span>
<a name="line-337"></a>
<a name="line-338"></a>                      <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ctEvPred</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>bagToList</span> <span class='hs-varid'>simples</span>
<a name="line-339"></a>                                             <span class='hs-layout'>,</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctEvidence</span> <span class='hs-varid'>ct</span>
<a name="line-340"></a>                                             <span class='hs-layout'>,</span> <span class='hs-varid'>isWanted</span> <span class='hs-varid'>ev</span> <span class='hs-keyglyph'>]</span> <span class='hs-layout'>}</span>
<a name="line-341"></a>
<a name="line-342"></a>       <span class='hs-comment'>-- NB: quant_pred_candidates is already the fixpoint of any</span>
<a name="line-343"></a>       <span class='hs-comment'>--     unifications that may have happened</span>
<a name="line-344"></a>
<a name="line-345"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_taus</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>zonkTcType</span> <span class='hs-varop'>.</span> <span class='hs-varid'>snd</span><span class='hs-layout'>)</span> <span class='hs-varid'>name_taus</span>
<a name="line-346"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>zonked_taus</span>
<a name="line-347"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>promote_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>bound</span><span class='hs-layout'>,</span> <span class='hs-varid'>mr_bites</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>decideQuantification</span> <span class='hs-varid'>apply_mr</span> <span class='hs-varid'>quant_pred_candidates</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-348"></a>
<a name="line-349"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>outer_tclvl</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcRnMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>getTcLevel</span>
<a name="line-350"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>runTcSWithEvBinds</span> <span class='hs-varid'>null_ev_binds_var</span> <span class='hs-varop'>$</span>  <span class='hs-comment'>-- runTcS just to get the types right :-(</span>
<a name="line-351"></a>         <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>promoteTyVar</span> <span class='hs-varid'>outer_tclvl</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>varSetElems</span> <span class='hs-varid'>promote_tvs</span><span class='hs-layout'>)</span>
<a name="line-352"></a>
<a name="line-353"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>minimal_simple_preds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkMinimalBySCs</span> <span class='hs-varid'>bound</span>
<a name="line-354"></a>                  <span class='hs-comment'>-- See Note [Minimize by Superclasses]</span>
<a name="line-355"></a>             <span class='hs-varid'>skol_info</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>InferSkol</span> <span class='hs-keyglyph'>[</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>mkSigmaTy</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>minimal_simple_preds</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span>
<a name="line-356"></a>                                   <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-varid'>name</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>name_taus</span> <span class='hs-keyglyph'>]</span>
<a name="line-357"></a>                        <span class='hs-comment'>-- Don't add the quantified variables here, because</span>
<a name="line-358"></a>                        <span class='hs-comment'>-- they are also bound in ic_skols and we want them to be</span>
<a name="line-359"></a>                        <span class='hs-comment'>-- tidied uniformly</span>
<a name="line-360"></a>
<a name="line-361"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>minimal_bound_ev_vars</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>newEvVar</span> <span class='hs-varid'>minimal_simple_preds</span>
<a name="line-362"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>implic</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_tclvl</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>rhs_tclvl</span>
<a name="line-363"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>qtvs</span>
<a name="line-364"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_no_eqs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-365"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>minimal_bound_ev_vars</span>
<a name="line-366"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanted_transformed</span>
<a name="line-367"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>    <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-368"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-369"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_info</span>     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skol_info</span>
<a name="line-370"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_env</span>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tc_lcl_env</span> <span class='hs-layout'>}</span>
<a name="line-371"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>emitImplication</span> <span class='hs-varid'>implic</span>
<a name="line-372"></a>
<a name="line-373"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"} simplifyInfer/produced residual implication for quantification"</span> <span class='hs-varop'>$</span>
<a name="line-374"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"quant_pred_candidates ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>quant_pred_candidates</span>
<a name="line-375"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"zonked_taus"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_taus</span>
<a name="line-376"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"zonked_tau_tvs="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-377"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"promote_tvs="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>promote_tvs</span>
<a name="line-378"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"bound ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>bound</span>
<a name="line-379"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"minimal_bound ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>v</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>dcolon</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>idType</span> <span class='hs-varid'>v</span><span class='hs-layout'>)</span>
<a name="line-380"></a>                                                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>v</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>minimal_bound_ev_vars</span><span class='hs-keyglyph'>]</span>
<a name="line-381"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"mr_bites ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mr_bites</span>
<a name="line-382"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"qtvs ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs</span>
<a name="line-383"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"implic ="</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>implic</span> <span class='hs-keyglyph'>]</span>
<a name="line-384"></a>
<a name="line-385"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>minimal_bound_ev_vars</span>
<a name="line-386"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>mr_bites</span><span class='hs-layout'>,</span>  <span class='hs-conid'>TcEvBinds</span> <span class='hs-varid'>ev_binds_var</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-387"></a>
<a name="line-388"></a><span class='hs-comment'>{-
<a name="line-389"></a>************************************************************************
<a name="line-390"></a>*                                                                      *
<a name="line-391"></a>                Quantification
<a name="line-392"></a>*                                                                      *
<a name="line-393"></a>************************************************************************
<a name="line-394"></a>
<a name="line-395"></a>Note [Deciding quantification]
<a name="line-396"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-397"></a>If the monomorphism restriction does not apply, then we quantify as follows:
<a name="line-398"></a>  * Take the global tyvars, and "grow" them using the equality constraints
<a name="line-399"></a>    E.g.  if x:alpha is in the environment, and alpha ~ [beta] (which can
<a name="line-400"></a>          happen because alpha is untouchable here) then do not quantify over
<a name="line-401"></a>          beta
<a name="line-402"></a>    These are the mono_tvs
<a name="line-403"></a>
<a name="line-404"></a>  * Take the free vars of the tau-type (zonked_tau_tvs) and "grow" them
<a name="line-405"></a>    using all the constraints, but knocking out the mono_tvs
<a name="line-406"></a>
<a name="line-407"></a>    The result is poly_qtvs, which we will quantify over.
<a name="line-408"></a>
<a name="line-409"></a>  * Filter the constraints using quantifyPred and the poly_qtvs
<a name="line-410"></a>
<a name="line-411"></a>If the MR does apply, mono_tvs includes all the constrained tyvars,
<a name="line-412"></a>and the quantified constraints are empty.
<a name="line-413"></a>-}</span>
<a name="line-414"></a>
<a name="line-415"></a><a name="decideQuantification"></a><span class='hs-definition'>decideQuantification</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bool</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVarSet</span>
<a name="line-416"></a>                     <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span> <span class='hs-conid'>TcTyVarSet</span>      <span class='hs-comment'>-- Promote these</span>
<a name="line-417"></a>                            <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span>       <span class='hs-comment'>-- Do quantify over these</span>
<a name="line-418"></a>                            <span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>PredType</span><span class='hs-keyglyph'>]</span>      <span class='hs-comment'>-- and these</span>
<a name="line-419"></a>                            <span class='hs-layout'>,</span> <span class='hs-conid'>Bool</span> <span class='hs-layout'>)</span>          <span class='hs-comment'>-- Did the MR bite?</span>
<a name="line-420"></a><span class='hs-comment'>-- See Note [Deciding quantification]</span>
<a name="line-421"></a><span class='hs-definition'>decideQuantification</span> <span class='hs-varid'>apply_mr</span> <span class='hs-varid'>constraints</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-422"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>apply_mr</span>     <span class='hs-comment'>-- Apply the Monomorphism restriction</span>
<a name="line-423"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-424"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>mono_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>constrained_tvs</span>
<a name="line-425"></a>             <span class='hs-varid'>mr_bites</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>constrained_tvs</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-426"></a>             <span class='hs-varid'>promote_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>constrained_tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-layout'>(</span><span class='hs-varid'>zonked_tau_tvs</span> <span class='hs-varop'>`intersectVarSet`</span> <span class='hs-varid'>gbl_tvs</span><span class='hs-layout'>)</span>
<a name="line-427"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>quantifyTyVars</span> <span class='hs-varid'>mono_tvs</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-428"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"decideQuantification 1"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>constraints</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>gbl_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mono_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-429"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>promote_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-conid'>[]</span><span class='hs-layout'>,</span> <span class='hs-varid'>mr_bites</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-430"></a>
<a name="line-431"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-432"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetGlobalTyVars</span>
<a name="line-433"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>mono_tvs</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growThetaTyVars</span> <span class='hs-layout'>(</span><span class='hs-varid'>filter</span> <span class='hs-varid'>isEqPred</span> <span class='hs-varid'>constraints</span><span class='hs-layout'>)</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-434"></a>             <span class='hs-varid'>poly_qtvs</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>growThetaTyVars</span> <span class='hs-varid'>constraints</span> <span class='hs-varid'>zonked_tau_tvs</span>
<a name="line-435"></a>                           <span class='hs-varop'>`minusVarSet`</span> <span class='hs-varid'>mono_tvs</span>
<a name="line-436"></a>             <span class='hs-varid'>theta</span>       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-varid'>quantifyPred</span> <span class='hs-varid'>poly_qtvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>constraints</span>
<a name="line-437"></a>             <span class='hs-varid'>promote_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mono_tvs</span> <span class='hs-varop'>`intersectVarSet`</span> <span class='hs-layout'>(</span><span class='hs-varid'>constrained_tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>zonked_tau_tvs</span><span class='hs-layout'>)</span>
<a name="line-438"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>qtvs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>quantifyTyVars</span> <span class='hs-varid'>mono_tvs</span> <span class='hs-varid'>poly_qtvs</span>
<a name="line-439"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"decideQuantification 2"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>constraints</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>gbl_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>mono_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>poly_qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>theta</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-440"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>promote_tvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>qtvs</span><span class='hs-layout'>,</span> <span class='hs-varid'>theta</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-441"></a>  <span class='hs-keyword'>where</span>
<a name="line-442"></a>    <span class='hs-varid'>constrained_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>constraints</span>
<a name="line-443"></a>
<a name="line-444"></a><a name="quantifyPred"></a><span class='hs-comment'>------------------</span>
<a name="line-445"></a><span class='hs-definition'>quantifyPred</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TyVarSet</span>           <span class='hs-comment'>-- Quantifying over these</span>
<a name="line-446"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>PredType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- True &lt;=&gt; quantify over this wanted</span>
<a name="line-447"></a><span class='hs-definition'>quantifyPred</span> <span class='hs-varid'>qtvs</span> <span class='hs-varid'>pred</span>
<a name="line-448"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span> <span class='hs-keyword'>of</span>
<a name="line-449"></a>      <span class='hs-conid'>ClassPred</span> <span class='hs-varid'>cls</span> <span class='hs-varid'>tys</span>
<a name="line-450"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isIPClass</span> <span class='hs-varid'>cls</span>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span> <span class='hs-comment'>-- See note [Inheriting implicit parameters]</span>
<a name="line-451"></a>         <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>qtvs</span>
<a name="line-452"></a>      <span class='hs-conid'>EqPred</span> <span class='hs-conid'>NomEq</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>quant_fun</span> <span class='hs-varid'>ty1</span> <span class='hs-varop'>||</span> <span class='hs-varid'>quant_fun</span> <span class='hs-varid'>ty2</span>
<a name="line-453"></a>        <span class='hs-comment'>-- representational equality is like a class constraint</span>
<a name="line-454"></a>      <span class='hs-conid'>EqPred</span> <span class='hs-conid'>ReprEq</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty2</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>qtvs</span>
<a name="line-455"></a>      <span class='hs-conid'>IrredPred</span> <span class='hs-varid'>ty</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>ty</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>qtvs</span>
<a name="line-456"></a>      <span class='hs-conid'>TuplePred</span> <span class='hs-layout'>{</span><span class='hs-layout'>}</span>          <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-457"></a>  <span class='hs-keyword'>where</span>
<a name="line-458"></a>    <span class='hs-comment'>-- Only quantify over (F tys ~ ty) if tys mentions a quantifed variable</span>
<a name="line-459"></a>    <span class='hs-comment'>-- In particular, quanitifying over (F Int ~ ty) is a bit like quantifying</span>
<a name="line-460"></a>    <span class='hs-comment'>-- over (Eq Int); the instance should kick in right here</span>
<a name="line-461"></a>    <span class='hs-varid'>quant_fun</span> <span class='hs-varid'>ty</span>
<a name="line-462"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>tcSplitTyConApp_maybe</span> <span class='hs-varid'>ty</span> <span class='hs-keyword'>of</span>
<a name="line-463"></a>          <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>tc</span><span class='hs-layout'>,</span> <span class='hs-varid'>tys</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isTypeFamilyTyCon</span> <span class='hs-varid'>tc</span>
<a name="line-464"></a>                         <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>tys</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>qtvs</span>
<a name="line-465"></a>          <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-466"></a>
<a name="line-467"></a><a name="growThetaTyVars"></a><span class='hs-comment'>------------------</span>
<a name="line-468"></a><span class='hs-definition'>growThetaTyVars</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ThetaType</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVarSet</span>
<a name="line-469"></a><span class='hs-comment'>-- See Note [Growing the tau-tvs using constraints]</span>
<a name="line-470"></a><span class='hs-definition'>growThetaTyVars</span> <span class='hs-varid'>theta</span> <span class='hs-varid'>tvs</span>
<a name="line-471"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>theta</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-472"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyVarSet</span> <span class='hs-varid'>seed_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-473"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>              <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fixVarSet</span> <span class='hs-varid'>mk_next</span> <span class='hs-varid'>seed_tvs</span>
<a name="line-474"></a>  <span class='hs-keyword'>where</span>
<a name="line-475"></a>    <span class='hs-varid'>seed_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>tyVarsOfTypes</span> <span class='hs-varid'>ips</span>
<a name="line-476"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>ips</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_ips</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partition</span> <span class='hs-varid'>isIPPred</span> <span class='hs-varid'>theta</span>
<a name="line-477"></a>                         <span class='hs-comment'>-- See note [Inheriting implicit parameters]</span>
<a name="line-478"></a>    <span class='hs-varid'>mk_next</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>grow_one</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>non_ips</span>
<a name="line-479"></a>    <span class='hs-varid'>grow_one</span> <span class='hs-varid'>pred</span> <span class='hs-varid'>tvs</span>
<a name="line-480"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>pred_tvs</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>pred_tvs</span>
<a name="line-481"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                       <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-482"></a>       <span class='hs-keyword'>where</span>
<a name="line-483"></a>         <span class='hs-varid'>pred_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>pred</span>
<a name="line-484"></a>
<a name="line-485"></a><span class='hs-comment'>{-
<a name="line-486"></a>Note [Growing the tau-tvs using constraints]
<a name="line-487"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-488"></a>(growThetaTyVars insts tvs) is the result of extending the set
<a name="line-489"></a>    of tyvars tvs using all conceivable links from pred
<a name="line-490"></a>
<a name="line-491"></a>E.g. tvs = {a}, preds = {H [a] b, K (b,Int) c, Eq e}
<a name="line-492"></a>Then growThetaTyVars preds tvs = {a,b,c}
<a name="line-493"></a>
<a name="line-494"></a>Notice that
<a name="line-495"></a>   growThetaTyVars is conservative       if v might be fixed by vs
<a name="line-496"></a>                                         =&gt; v `elem` grow(vs,C)
<a name="line-497"></a>
<a name="line-498"></a>Note [Inheriting implicit parameters]
<a name="line-499"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-500"></a>Consider this:
<a name="line-501"></a>
<a name="line-502"></a>        f x = (x::Int) + ?y
<a name="line-503"></a>
<a name="line-504"></a>where f is *not* a top-level binding.
<a name="line-505"></a>From the RHS of f we'll get the constraint (?y::Int).
<a name="line-506"></a>There are two types we might infer for f:
<a name="line-507"></a>
<a name="line-508"></a>        f :: Int -&gt; Int
<a name="line-509"></a>
<a name="line-510"></a>(so we get ?y from the context of f's definition), or
<a name="line-511"></a>
<a name="line-512"></a>        f :: (?y::Int) =&gt; Int -&gt; Int
<a name="line-513"></a>
<a name="line-514"></a>At first you might think the first was better, because then
<a name="line-515"></a>?y behaves like a free variable of the definition, rather than
<a name="line-516"></a>having to be passed at each call site.  But of course, the WHOLE
<a name="line-517"></a>IDEA is that ?y should be passed at each call site (that's what
<a name="line-518"></a>dynamic binding means) so we'd better infer the second.
<a name="line-519"></a>
<a name="line-520"></a>BOTTOM LINE: when *inferring types* you must quantify over implicit
<a name="line-521"></a>parameters, *even if* they don't mention the bound type variables.
<a name="line-522"></a>Reason: because implicit parameters, uniquely, have local instance
<a name="line-523"></a>declarations. See the predicate quantifyPred.
<a name="line-524"></a>
<a name="line-525"></a>Note [Quantification with errors]
<a name="line-526"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-527"></a>If we find that the RHS of the definition has some absolutely-insoluble
<a name="line-528"></a>constraints, we abandon all attempts to find a context to quantify
<a name="line-529"></a>over, and instead make the function fully-polymorphic in whatever
<a name="line-530"></a>type we have found.  For two reasons
<a name="line-531"></a>  a) Minimise downstream errors
<a name="line-532"></a>  b) Avoid spurious errors from this function
<a name="line-533"></a>
<a name="line-534"></a>But NB that we must include *derived* errors in the check. Example:
<a name="line-535"></a>    (a::*) ~ Int#
<a name="line-536"></a>We get an insoluble derived error *~#, and we don't want to discard
<a name="line-537"></a>it before doing the isInsolubleWC test!  (Trac #8262)
<a name="line-538"></a>
<a name="line-539"></a>Note [Default while Inferring]
<a name="line-540"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-541"></a>Our current plan is that defaulting only happens at simplifyTop and
<a name="line-542"></a>not simplifyInfer.  This may lead to some insoluble deferred constraints
<a name="line-543"></a>Example:
<a name="line-544"></a>
<a name="line-545"></a>instance D g =&gt; C g Int b
<a name="line-546"></a>
<a name="line-547"></a>constraint inferred = (forall b. 0 =&gt; C gamma alpha b) /\ Num alpha
<a name="line-548"></a>type inferred       = gamma -&gt; gamma
<a name="line-549"></a>
<a name="line-550"></a>Now, if we try to default (alpha := Int) we will be able to refine the implication to
<a name="line-551"></a>  (forall b. 0 =&gt; C gamma Int b)
<a name="line-552"></a>which can then be simplified further to
<a name="line-553"></a>  (forall b. 0 =&gt; D gamma)
<a name="line-554"></a>Finally we /can/ approximate this implication with (D gamma) and infer the quantified
<a name="line-555"></a>type:  forall g. D g =&gt; g -&gt; g
<a name="line-556"></a>
<a name="line-557"></a>Instead what will currently happen is that we will get a quantified type
<a name="line-558"></a>(forall g. g -&gt; g) and an implication:
<a name="line-559"></a>       forall g. 0 =&gt; (forall b. 0 =&gt; C g alpha b) /\ Num alpha
<a name="line-560"></a>
<a name="line-561"></a>which, even if the simplifyTop defaults (alpha := Int) we will still be left with an
<a name="line-562"></a>unsolvable implication:
<a name="line-563"></a>       forall g. 0 =&gt; (forall b. 0 =&gt; D g)
<a name="line-564"></a>
<a name="line-565"></a>The concrete example would be:
<a name="line-566"></a>       h :: C g a s =&gt; g -&gt; a -&gt; ST s a
<a name="line-567"></a>       f (x::gamma) = (\_ -&gt; x) (runST (h x (undefined::alpha)) + 1)
<a name="line-568"></a>
<a name="line-569"></a>But it is quite tedious to do defaulting and resolve the implication constraints and
<a name="line-570"></a>we have not observed code breaking because of the lack of defaulting in inference so
<a name="line-571"></a>we don't do it for now.
<a name="line-572"></a>
<a name="line-573"></a>
<a name="line-574"></a>
<a name="line-575"></a>Note [Minimize by Superclasses]
<a name="line-576"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-577"></a>When we quantify over a constraint, in simplifyInfer we need to
<a name="line-578"></a>quantify over a constraint that is minimal in some sense: For
<a name="line-579"></a>instance, if the final wanted constraint is (Eq alpha, Ord alpha),
<a name="line-580"></a>we'd like to quantify over Ord alpha, because we can just get Eq alpha
<a name="line-581"></a>from superclass selection from Ord alpha. This minimization is what
<a name="line-582"></a>mkMinimalBySCs does. Then, simplifyInfer uses the minimal constraint
<a name="line-583"></a>to check the original wanted.
<a name="line-584"></a>
<a name="line-585"></a>
<a name="line-586"></a>Note [Avoid unecessary constraint simplification]
<a name="line-587"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-588"></a>    -------- NB NB NB (Jun 12) -------------
<a name="line-589"></a>    This note not longer applies; see the notes with Trac #4361.
<a name="line-590"></a>    But I'm leaving it in here so we remember the issue.)
<a name="line-591"></a>    ----------------------------------------
<a name="line-592"></a>When inferring the type of a let-binding, with simplifyInfer,
<a name="line-593"></a>try to avoid unnecessarily simplifying class constraints.
<a name="line-594"></a>Doing so aids sharing, but it also helps with delicate
<a name="line-595"></a>situations like
<a name="line-596"></a>
<a name="line-597"></a>   instance C t =&gt; C [t] where ..
<a name="line-598"></a>
<a name="line-599"></a>   f :: C [t] =&gt; ....
<a name="line-600"></a>   f x = let g y = ...(constraint C [t])...
<a name="line-601"></a>         in ...
<a name="line-602"></a>When inferring a type for 'g', we don't want to apply the
<a name="line-603"></a>instance decl, because then we can't satisfy (C t).  So we
<a name="line-604"></a>just notice that g isn't quantified over 't' and partition
<a name="line-605"></a>the constraints before simplifying.
<a name="line-606"></a>
<a name="line-607"></a>This only half-works, but then let-generalisation only half-works.
<a name="line-608"></a>
<a name="line-609"></a>
<a name="line-610"></a>*********************************************************************************
<a name="line-611"></a>*                                                                                 *
<a name="line-612"></a>*                             RULES                                               *
<a name="line-613"></a>*                                                                                 *
<a name="line-614"></a>***********************************************************************************
<a name="line-615"></a>
<a name="line-616"></a>See note [Simplifying RULE constraints] in TcRule
<a name="line-617"></a>
<a name="line-618"></a>Note [RULE quantification over equalities]
<a name="line-619"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-620"></a>Deciding which equalities to quantify over is tricky:
<a name="line-621"></a> * We do not want to quantify over insoluble equalities (Int ~ Bool)
<a name="line-622"></a>    (a) because we prefer to report a LHS type error
<a name="line-623"></a>    (b) because if such things end up in 'givens' we get a bogus
<a name="line-624"></a>        "inaccessible code" error
<a name="line-625"></a>
<a name="line-626"></a> * But we do want to quantify over things like (a ~ F b), where
<a name="line-627"></a>   F is a type function.
<a name="line-628"></a>
<a name="line-629"></a>The difficulty is that it's hard to tell what is insoluble!
<a name="line-630"></a>So we see whether the simplificaiotn step yielded any type errors,
<a name="line-631"></a>and if so refrain from quantifying over *any* equalites.
<a name="line-632"></a>-}</span>
<a name="line-633"></a>
<a name="line-634"></a><a name="simplifyRule"></a><span class='hs-definition'>simplifyRule</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>RuleName</span>
<a name="line-635"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>       <span class='hs-comment'>-- Constraints from LHS</span>
<a name="line-636"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>       <span class='hs-comment'>-- Constraints from RHS</span>
<a name="line-637"></a>             <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-conid'>EvVar</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- LHS evidence variables</span>
<a name="line-638"></a><span class='hs-comment'>-- See Note [Simplifying RULE constraints] in TcRule</span>
<a name="line-639"></a><span class='hs-definition'>simplifyRule</span> <span class='hs-varid'>name</span> <span class='hs-varid'>lhs_wanted</span> <span class='hs-varid'>rhs_wanted</span>
<a name="line-640"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>         <span class='hs-comment'>-- We allow ourselves to unify environment</span>
<a name="line-641"></a>                 <span class='hs-comment'>-- variables: runTcS runs with topTcLevel</span>
<a name="line-642"></a>         <span class='hs-layout'>(</span><span class='hs-varid'>resid_wanted</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcM</span> <span class='hs-layout'>(</span><span class='hs-varid'>lhs_wanted</span> <span class='hs-varop'>`andWC`</span> <span class='hs-varid'>rhs_wanted</span><span class='hs-layout'>)</span>
<a name="line-643"></a>                              <span class='hs-comment'>-- Post: these are zonked and unflattened</span>
<a name="line-644"></a>
<a name="line-645"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonked_lhs_simples</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>zonkSimples</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_simple</span> <span class='hs-varid'>lhs_wanted</span><span class='hs-layout'>)</span>
<a name="line-646"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>q_cts</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_q_cts</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>quantify_me</span> <span class='hs-varid'>zonked_lhs_simples</span>
<a name="line-647"></a>             <span class='hs-varid'>quantify_me</span>  <span class='hs-comment'>-- Note [RULE quantification over equalities]</span>
<a name="line-648"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>resid_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quantify_insol</span>
<a name="line-649"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                <span class='hs-keyglyph'>=</span> <span class='hs-varid'>quantify_normal</span>
<a name="line-650"></a>
<a name="line-651"></a>             <span class='hs-varid'>quantify_insol</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEqPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-652"></a>
<a name="line-653"></a>             <span class='hs-varid'>quantify_normal</span> <span class='hs-varid'>ct</span>
<a name="line-654"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-conid'>EqPred</span> <span class='hs-conid'>NomEq</span> <span class='hs-varid'>t1</span> <span class='hs-varid'>t2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span><span class='hs-layout'>)</span>
<a name="line-655"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>t1</span> <span class='hs-varop'>`tcEqType`</span> <span class='hs-varid'>t2</span><span class='hs-layout'>)</span>
<a name="line-656"></a>               <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-657"></a>               <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-658"></a>
<a name="line-659"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"simplifyRule"</span> <span class='hs-varop'>$</span>
<a name="line-660"></a>         <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>ptext</span> <span class='hs-layout'>(</span><span class='hs-varid'>sLit</span> <span class='hs-str'>"LHS of rule"</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>doubleQuotes</span> <span class='hs-layout'>(</span><span class='hs-varid'>ftext</span> <span class='hs-varid'>name</span><span class='hs-layout'>)</span>
<a name="line-661"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"zonked_lhs_simples"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>zonked_lhs_simples</span>
<a name="line-662"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"q_cts"</span>      <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>q_cts</span>
<a name="line-663"></a>              <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"non_q_cts"</span>  <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>non_q_cts</span> <span class='hs-keyglyph'>]</span>
<a name="line-664"></a>
<a name="line-665"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctEvId</span> <span class='hs-varop'>.</span> <span class='hs-varid'>ctEvidence</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>q_cts</span><span class='hs-layout'>)</span>
<a name="line-666"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>lhs_wanted</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>non_q_cts</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-667"></a>
<a name="line-668"></a><span class='hs-comment'>{-
<a name="line-669"></a>*********************************************************************************
<a name="line-670"></a>*                                                                                 *
<a name="line-671"></a>*                                 Main Simplifier                                 *
<a name="line-672"></a>*                                                                                 *
<a name="line-673"></a>***********************************************************************************
<a name="line-674"></a>
<a name="line-675"></a>Note [Deferring coercion errors to runtime]
<a name="line-676"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-677"></a>While developing, sometimes it is desirable to allow compilation to succeed even
<a name="line-678"></a>if there are type errors in the code. Consider the following case:
<a name="line-679"></a>
<a name="line-680"></a>  module Main where
<a name="line-681"></a>
<a name="line-682"></a>  a :: Int
<a name="line-683"></a>  a = 'a'
<a name="line-684"></a>
<a name="line-685"></a>  main = print "b"
<a name="line-686"></a>
<a name="line-687"></a>Even though `a` is ill-typed, it is not used in the end, so if all that we're
<a name="line-688"></a>interested in is `main` it is handy to be able to ignore the problems in `a`.
<a name="line-689"></a>
<a name="line-690"></a>Since we treat type equalities as evidence, this is relatively simple. Whenever
<a name="line-691"></a>we run into a type mismatch in TcUnify, we normally just emit an error. But it
<a name="line-692"></a>is always safe to defer the mismatch to the main constraint solver. If we do
<a name="line-693"></a>that, `a` will get transformed into
<a name="line-694"></a>
<a name="line-695"></a>  co :: Int ~ Char
<a name="line-696"></a>  co = ...
<a name="line-697"></a>
<a name="line-698"></a>  a :: Int
<a name="line-699"></a>  a = 'a' `cast` co
<a name="line-700"></a>
<a name="line-701"></a>The constraint solver would realize that `co` is an insoluble constraint, and
<a name="line-702"></a>emit an error with `reportUnsolved`. But we can also replace the right-hand side
<a name="line-703"></a>of `co` with `error "Deferred type error: Int ~ Char"`. This allows the program
<a name="line-704"></a>to compile, and it will run fine unless we evaluate `a`. This is what
<a name="line-705"></a>`deferErrorsToRuntime` does.
<a name="line-706"></a>
<a name="line-707"></a>It does this by keeping track of which errors correspond to which coercion
<a name="line-708"></a>in TcErrors (with ErrEnv). TcErrors.reportTidyWanteds does not print the errors
<a name="line-709"></a>and does not fail if -fdefer-type-errors is on, so that we can continue
<a name="line-710"></a>compilation. The errors are turned into warnings in `reportUnsolved`.
<a name="line-711"></a>
<a name="line-712"></a>Note [Zonk after solving]
<a name="line-713"></a>~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-714"></a>We zonk the result immediately after constraint solving, for two reasons:
<a name="line-715"></a>
<a name="line-716"></a>a) because zonkWC generates evidence, and this is the moment when we
<a name="line-717"></a>   have a suitable evidence variable to hand.
<a name="line-718"></a>
<a name="line-719"></a>Note that *after* solving the constraints are typically small, so the
<a name="line-720"></a>overhead is not great.
<a name="line-721"></a>-}</span>
<a name="line-722"></a>
<a name="line-723"></a><a name="solveWantedsTcMWithEvBinds"></a><span class='hs-definition'>solveWantedsTcMWithEvBinds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>EvBindsVar</span>
<a name="line-724"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-725"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>
<a name="line-726"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-727"></a><span class='hs-comment'>-- Returns a *zonked* result</span>
<a name="line-728"></a><span class='hs-comment'>-- We zonk when we finish primarily to un-flatten out any</span>
<a name="line-729"></a><span class='hs-comment'>-- flatten-skolems etc introduced by canonicalisation of</span>
<a name="line-730"></a><span class='hs-comment'>-- types involving type funuctions.  Happily the result</span>
<a name="line-731"></a><span class='hs-comment'>-- is typically much smaller than the input, indeed it is</span>
<a name="line-732"></a><span class='hs-comment'>-- often empty.</span>
<a name="line-733"></a><span class='hs-definition'>solveWantedsTcMWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wc</span> <span class='hs-varid'>tcs_action</span>
<a name="line-734"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTc</span> <span class='hs-str'>"solveWantedsTcMWithEvBinds"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"wanted="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wc</span>
<a name="line-735"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wc2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>runTcSWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcs_action</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span>
<a name="line-736"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>zonkWC</span> <span class='hs-varid'>wc2</span> <span class='hs-layout'>}</span>
<a name="line-737"></a>         <span class='hs-comment'>-- See Note [Zonk after solving]</span>
<a name="line-738"></a>
<a name="line-739"></a><a name="solveWantedsTcM"></a><span class='hs-definition'>solveWantedsTcM</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcM</span> <span class='hs-layout'>(</span><span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>EvBind</span><span class='hs-layout'>)</span>
<a name="line-740"></a><span class='hs-comment'>-- Zonk the input constraints, and simplify them</span>
<a name="line-741"></a><span class='hs-comment'>-- Return the evidence binds in the BagEvBinds result</span>
<a name="line-742"></a><span class='hs-comment'>-- Discards all Derived stuff in result</span>
<a name="line-743"></a><span class='hs-comment'>-- Postcondition: fully zonked and unflattened constraints</span>
<a name="line-744"></a><span class='hs-definition'>solveWantedsTcM</span> <span class='hs-varid'>wanted</span>
<a name="line-745"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcM</span><span class='hs-varop'>.</span><span class='hs-varid'>newTcEvBinds</span>
<a name="line-746"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wanteds'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWantedsTcMWithEvBinds</span> <span class='hs-varid'>ev_binds_var</span> <span class='hs-varid'>wanted</span> <span class='hs-varid'>solveWantedsAndDrop</span>
<a name="line-747"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>binds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcRnMonad</span><span class='hs-varop'>.</span><span class='hs-varid'>getTcEvBinds</span> <span class='hs-varid'>ev_binds_var</span>
<a name="line-748"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wanteds'</span><span class='hs-layout'>,</span> <span class='hs-varid'>binds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-749"></a>
<a name="line-750"></a><a name="solveWantedsAndDrop"></a><span class='hs-definition'>solveWantedsAndDrop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>
<a name="line-751"></a><span class='hs-comment'>-- Since solveWanteds returns the residual WantedConstraints,</span>
<a name="line-752"></a><span class='hs-comment'>-- it should always be called within a runTcS or something similar,</span>
<a name="line-753"></a><span class='hs-definition'>solveWantedsAndDrop</span> <span class='hs-varid'>wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>wanted</span>
<a name="line-754"></a>                                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>dropDerivedWC</span> <span class='hs-varid'>wc</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-755"></a>
<a name="line-756"></a><a name="solveWanteds"></a><span class='hs-definition'>solveWanteds</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-757"></a><span class='hs-comment'>-- so that the inert set doesn't mindlessly propagate.</span>
<a name="line-758"></a><span class='hs-comment'>-- NB: wc_simples may be wanted /or/ derived now</span>
<a name="line-759"></a><span class='hs-definition'>solveWanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-760"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-761"></a>
<a name="line-762"></a>         <span class='hs-comment'>-- Try the simple bit, including insolubles. Solving insolubles a</span>
<a name="line-763"></a>         <span class='hs-comment'>-- second time round is a bit of a waste; but the code is simple</span>
<a name="line-764"></a>         <span class='hs-comment'>-- and the program is wrong anyway, and we don't run the danger</span>
<a name="line-765"></a>         <span class='hs-comment'>-- of adding Derived insolubles twice; see</span>
<a name="line-766"></a>         <span class='hs-comment'>-- TcSMonad Note [Do not add duplicate derived insolubles]</span>
<a name="line-767"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveSimples {"</span> <span class='hs-varid'>empty</span>
<a name="line-768"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>solved_simples_wanteds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveSimples</span> <span class='hs-varid'>wanteds</span>
<a name="line-769"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveSimples end }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>solved_simples_wanteds</span><span class='hs-layout'>)</span>
<a name="line-770"></a>
<a name="line-771"></a>       <span class='hs-comment'>-- solveWanteds iterates when it is able to float equalities</span>
<a name="line-772"></a>       <span class='hs-comment'>-- equalities out of one or more of the implications.</span>
<a name="line-773"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>final_wanteds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>simpl_loop</span> <span class='hs-num'>1</span> <span class='hs-varid'>solved_simples_wanteds</span>
<a name="line-774"></a>
<a name="line-775"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>bb</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcEvBindsMap</span>
<a name="line-776"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds }"</span> <span class='hs-varop'>$</span>
<a name="line-777"></a>                 <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"final wc ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>final_wanteds</span>
<a name="line-778"></a>                      <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"current evbinds  ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>bb</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-779"></a>
<a name="line-780"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>final_wanteds</span> <span class='hs-layout'>}</span>
<a name="line-781"></a>
<a name="line-782"></a><a name="solveSimples"></a><span class='hs-definition'>solveSimples</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-783"></a><span class='hs-comment'>-- Solve the wc_simple and wc_insol components of the WantedConstraints</span>
<a name="line-784"></a><span class='hs-comment'>-- Do not affect the inerts</span>
<a name="line-785"></a><span class='hs-definition'>solveSimples</span> <span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-786"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nestTcS</span> <span class='hs-varop'>$</span>
<a name="line-787"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>all_simples</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>filterBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>not</span> <span class='hs-varop'>.</span> <span class='hs-varid'>isDerivedCt</span><span class='hs-layout'>)</span> <span class='hs-varid'>insols</span>
<a name="line-788"></a>                     <span class='hs-comment'>-- See Note [Dropping derived constraints] in TcRnTypes for</span>
<a name="line-789"></a>                     <span class='hs-comment'>-- why the insolubles may have derived constraints</span>
<a name="line-790"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>wc</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveSimpleWanteds</span> <span class='hs-varid'>all_simples</span>
<a name="line-791"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span> <span class='hs-varid'>wc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>wc_impl</span> <span class='hs-varid'>wc</span> <span class='hs-layout'>}</span> <span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-792"></a>
<a name="line-793"></a><a name="simpl_loop"></a><span class='hs-definition'>simpl_loop</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Int</span>
<a name="line-794"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-795"></a>           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-796"></a><span class='hs-definition'>simpl_loop</span> <span class='hs-varid'>n</span> <span class='hs-varid'>wanteds</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-797"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>n</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>10</span>
<a name="line-798"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveWanteds: loop!"</span> <span class='hs-varid'>empty</span>
<a name="line-799"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>wanteds</span> <span class='hs-layout'>}</span>
<a name="line-800"></a>
<a name="line-801"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-802"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"simpl_loop, iteration"</span> <span class='hs-layout'>(</span><span class='hs-varid'>int</span> <span class='hs-varid'>n</span><span class='hs-layout'>)</span>
<a name="line-803"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveNestedImplications</span> <span class='hs-varid'>implics</span>
<a name="line-804"></a>
<a name="line-805"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>floated_eqs</span>
<a name="line-806"></a>         <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>wanteds</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-807"></a>         <span class='hs-keyword'>else</span>
<a name="line-808"></a>
<a name="line-809"></a>    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>   <span class='hs-comment'>-- Put floated_eqs into the current inert set before looping</span>
<a name="line-810"></a>         <span class='hs-layout'>(</span><span class='hs-varid'>unifs_happened</span><span class='hs-layout'>,</span> <span class='hs-varid'>solve_simple_res</span><span class='hs-layout'>)</span>
<a name="line-811"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>reportUnifications</span> <span class='hs-varop'>$</span>
<a name="line-812"></a>                <span class='hs-varid'>solveSimples</span> <span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>floated_eqs</span> <span class='hs-varop'>`unionBags`</span> <span class='hs-varid'>simples</span>
<a name="line-813"></a>                                 <span class='hs-comment'>-- Put floated_eqs first so they get solved first</span>
<a name="line-814"></a>                                 <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-815"></a>
<a name="line-816"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>new_wanteds</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>solve_simple_res</span> <span class='hs-varop'>`andWC`</span>
<a name="line-817"></a>                           <span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span>
<a name="line-818"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>wc_insol</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insols</span>
<a name="line-819"></a>                              <span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-layout'>}</span>
<a name="line-820"></a>
<a name="line-821"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span>   <span class='hs-varid'>not</span> <span class='hs-varid'>unifs_happened</span>   <span class='hs-comment'>-- See Note [Cutting off simpl_loop]</span>
<a name="line-822"></a>           <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>wc_impl</span> <span class='hs-varid'>solve_simple_res</span><span class='hs-layout'>)</span>
<a name="line-823"></a>         <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>new_wanteds</span>
<a name="line-824"></a>         <span class='hs-keyword'>else</span> <span class='hs-varid'>simpl_loop</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-varop'>+</span><span class='hs-num'>1</span><span class='hs-layout'>)</span> <span class='hs-varid'>new_wanteds</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-825"></a>
<a name="line-826"></a><a name="solveNestedImplications"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span>
<a name="line-827"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span>
<a name="line-828"></a><span class='hs-comment'>-- Precondition: the TcS inerts may contain unsolved simples which have</span>
<a name="line-829"></a><span class='hs-comment'>-- to be converted to givens before we go inside a nested implication.</span>
<a name="line-830"></a><span class='hs-definition'>solveNestedImplications</span> <span class='hs-varid'>implics</span>
<a name="line-831"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>implics</span>
<a name="line-832"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>emptyBag</span><span class='hs-layout'>)</span>
<a name="line-833"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-834"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span>
<a name="line-835"></a><span class='hs-comment'>--         inerts &lt;- getTcSInerts</span>
<a name="line-836"></a><span class='hs-comment'>--       ; let thinner_inerts = prepareInertsForImplications inerts</span>
<a name="line-837"></a><span class='hs-comment'>--                 -- See Note [Preparing inert set for implications]</span>
<a name="line-838"></a><span class='hs-comment'>--</span>
<a name="line-839"></a>           <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveNestedImplications starting {"</span> <span class='hs-varid'>empty</span>
<a name="line-840"></a><span class='hs-comment'>--           vcat [ text "original inerts = " &lt;+&gt; ppr inerts</span>
<a name="line-841"></a><span class='hs-comment'>--                , text "thinner_inerts  = " &lt;+&gt; ppr thinner_inerts ]</span>
<a name="line-842"></a>
<a name="line-843"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span>
<a name="line-844"></a>           <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>flatMapBagPairM</span> <span class='hs-varid'>solveImplication</span> <span class='hs-varid'>implics</span>
<a name="line-845"></a>
<a name="line-846"></a>       <span class='hs-comment'>-- ... and we are back in the original TcS inerts</span>
<a name="line-847"></a>       <span class='hs-comment'>-- Notice that the original includes the _insoluble_simples so it was safe to ignore</span>
<a name="line-848"></a>       <span class='hs-comment'>-- them in the beginning of this function.</span>
<a name="line-849"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveNestedImplications end }"</span> <span class='hs-varop'>$</span>
<a name="line-850"></a>                  <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"all floated_eqs ="</span>  <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>floated_eqs</span>
<a name="line-851"></a>                       <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"unsolved_implics ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>unsolved_implics</span> <span class='hs-keyglyph'>]</span>
<a name="line-852"></a>
<a name="line-853"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>unsolved_implics</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-854"></a>
<a name="line-855"></a><a name="solveImplication"></a><span class='hs-definition'>solveImplication</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Implication</span>    <span class='hs-comment'>-- Wanted</span>
<a name="line-856"></a>                 <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span>      <span class='hs-comment'>-- All wanted or derived floated equalities: var = type</span>
<a name="line-857"></a>                         <span class='hs-conid'>Bag</span> <span class='hs-conid'>Implication</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Unsolved rest (always empty or singleton)</span>
<a name="line-858"></a><span class='hs-comment'>-- Precondition: The TcS monad contains an empty worklist and given-only inerts</span>
<a name="line-859"></a><span class='hs-comment'>-- which after trying to solve this implication we must restore to their original value</span>
<a name="line-860"></a><span class='hs-definition'>solveImplication</span> <span class='hs-varid'>imp</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Implic</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_tclvl</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tclvl</span>
<a name="line-861"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_binds</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ev_binds</span>
<a name="line-862"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_skols</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>skols</span>
<a name="line-863"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_given</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>givens</span>
<a name="line-864"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>wanteds</span>
<a name="line-865"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_info</span>   <span class='hs-keyglyph'>=</span> <span class='hs-varid'>info</span>
<a name="line-866"></a>                             <span class='hs-layout'>,</span> <span class='hs-varid'>ic_env</span>    <span class='hs-keyglyph'>=</span> <span class='hs-varid'>env</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-867"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>inerts</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcSInerts</span>
<a name="line-868"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>imp</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Inerts"</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>inerts</span><span class='hs-layout'>)</span>
<a name="line-869"></a>
<a name="line-870"></a>         <span class='hs-comment'>-- Solve the nested constraints</span>
<a name="line-871"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>no_given_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span>
<a name="line-872"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestImplicTcS</span> <span class='hs-varid'>ev_binds</span> <span class='hs-varid'>tclvl</span> <span class='hs-varop'>$</span>
<a name="line-873"></a>               <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>solveSimpleGivens</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkGivenLoc</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>info</span> <span class='hs-varid'>env</span><span class='hs-layout'>)</span> <span class='hs-varid'>givens</span>
<a name="line-874"></a>
<a name="line-875"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>residual_wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveWanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-876"></a>                        <span class='hs-comment'>-- solveWanteds, *not* solveWantedsAndDrop, because</span>
<a name="line-877"></a>                        <span class='hs-comment'>-- we want to retain derived equalities so we can float</span>
<a name="line-878"></a>                        <span class='hs-comment'>-- them out in floatEqualities</span>
<a name="line-879"></a>
<a name="line-880"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>no_eqs</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getNoGivenEqs</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>skols</span>
<a name="line-881"></a>
<a name="line-882"></a>                  <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>no_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-883"></a>
<a name="line-884"></a>       <span class='hs-layout'>;</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>final_wanted</span><span class='hs-layout'>)</span>
<a name="line-885"></a>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>floatEqualities</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>no_given_eqs</span> <span class='hs-varid'>residual_wanted</span>
<a name="line-886"></a>
<a name="line-887"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>res_implic</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>final_wanted</span> <span class='hs-comment'>-- &amp;&amp; no_given_eqs</span>
<a name="line-888"></a>                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyBag</span>  <span class='hs-comment'>-- Reason for the no_given_eqs: we don't want to</span>
<a name="line-889"></a>                                    <span class='hs-comment'>-- lose the "inaccessible code" error message</span>
<a name="line-890"></a>                                    <span class='hs-comment'>-- BUT: final_wanted still has the derived insolubles</span>
<a name="line-891"></a>                                    <span class='hs-comment'>--      so it should be fine</span>
<a name="line-892"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-893"></a>                        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>unitBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>imp</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ic_no_eqs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>no_given_eqs</span>
<a name="line-894"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ic_wanted</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>dropDerivedWC</span> <span class='hs-varid'>final_wanted</span>
<a name="line-895"></a>                                       <span class='hs-layout'>,</span> <span class='hs-varid'>ic_insol</span>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>insolubleWC</span> <span class='hs-varid'>final_wanted</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-896"></a>
<a name="line-897"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>evbinds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getTcEvBindsMap</span>
<a name="line-898"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"solveImplication end }"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span>
<a name="line-899"></a>             <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"no_given_eqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>no_given_eqs</span>
<a name="line-900"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"floated_eqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>floated_eqs</span>
<a name="line-901"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"res_implic ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>res_implic</span>
<a name="line-902"></a>             <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"implication evbinds = "</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-layout'>(</span><span class='hs-varid'>evBindMapBinds</span> <span class='hs-varid'>evbinds</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>]</span>
<a name="line-903"></a>
<a name="line-904"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>floated_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>res_implic</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-905"></a>
<a name="line-906"></a><span class='hs-comment'>{-
<a name="line-907"></a>Note [Cutting off simpl_loop]
<a name="line-908"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-909"></a>It is very important not to iterate in simpl_loop unless there is a chance
<a name="line-910"></a>of progress.  Trac #8474 is a classic example:
<a name="line-911"></a>
<a name="line-912"></a>  * There's a deeply-nested chain of implication constraints.
<a name="line-913"></a>       ?x:alpha =&gt; ?y1:beta1 =&gt; ... ?yn:betan =&gt; [W] ?x:Int
<a name="line-914"></a>
<a name="line-915"></a>  * From the innermost one we get a [D] alpha ~ Int,
<a name="line-916"></a>    but alpha is untouchable until we get out to the outermost one
<a name="line-917"></a>
<a name="line-918"></a>  * We float [D] alpha~Int out (it is in floated_eqs), but since alpha
<a name="line-919"></a>    is untouchable, the solveInteract in simpl_loop makes no progress
<a name="line-920"></a>
<a name="line-921"></a>  * So there is no point in attempting to re-solve
<a name="line-922"></a>       ?yn:betan =&gt; [W] ?x:Int
<a name="line-923"></a>    because we'll just get the same [D] again
<a name="line-924"></a>
<a name="line-925"></a>  * If we *do* re-solve, we'll get an ininite loop. It is cut off by
<a name="line-926"></a>    the fixed bound of 10, but solving the next takes 10*10*...*10 (ie
<a name="line-927"></a>    exponentially many) iterations!
<a name="line-928"></a>
<a name="line-929"></a>Conclusion: we should iterate simpl_loop iff we will get more 'givens'
<a name="line-930"></a>in the inert set when solving the nested implications.  That is the
<a name="line-931"></a>result of prepareInertsForImplications is larger.  How can we tell
<a name="line-932"></a>this?
<a name="line-933"></a>
<a name="line-934"></a>Consider floated_eqs (all wanted or derived):
<a name="line-935"></a>
<a name="line-936"></a>(a) [W/D] CTyEqCan (a ~ ty).  This can give rise to a new given only by causing
<a name="line-937"></a>    a unification. So we count those unifications.
<a name="line-938"></a>
<a name="line-939"></a>(b) [W] CFunEqCan (F tys ~ xi).  Even though these are wanted, they
<a name="line-940"></a>    are pushed in as givens by prepareInertsForImplications.  See Note
<a name="line-941"></a>    [Preparing inert set for implications] in TcSMonad.  But because
<a name="line-942"></a>    of that very fact, we won't generate another copy if we iterate
<a name="line-943"></a>    simpl_loop.  So we iterate if there any of these
<a name="line-944"></a>-}</span>
<a name="line-945"></a>
<a name="line-946"></a><a name="promoteTyVar"></a><span class='hs-definition'>promoteTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcLevel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVar</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-947"></a><span class='hs-comment'>-- When we float a constraint out of an implication we must restore</span>
<a name="line-948"></a><span class='hs-comment'>-- invariant (MetaTvInv) in Note [TcLevel and untouchable type variables] in TcType</span>
<a name="line-949"></a><span class='hs-comment'>-- See Note [Promoting unification variables]</span>
<a name="line-950"></a><span class='hs-definition'>promoteTyVar</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>tv</span>
<a name="line-951"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isFloatedTouchableMetaTyVar</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>tv</span>
<a name="line-952"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>cloned_tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>cloneMetaTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-953"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>rhs_tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setMetaTyVarTcLevel</span> <span class='hs-varid'>cloned_tv</span> <span class='hs-varid'>tclvl</span>
<a name="line-954"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>tv</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>rhs_tv</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-955"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-956"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>()</span>
<a name="line-957"></a>
<a name="line-958"></a><a name="promoteAndDefaultTyVar"></a><span class='hs-definition'>promoteAndDefaultTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcLevel</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>()</span>
<a name="line-959"></a><span class='hs-comment'>-- See Note [Promote _and_ default when inferring]</span>
<a name="line-960"></a><span class='hs-definition'>promoteAndDefaultTyVar</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>gbl_tvs</span> <span class='hs-varid'>tv</span>
<a name="line-961"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tv1</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>gbl_tvs</span>
<a name="line-962"></a>                <span class='hs-keyword'>then</span> <span class='hs-varid'>return</span> <span class='hs-varid'>tv</span>
<a name="line-963"></a>                <span class='hs-keyword'>else</span> <span class='hs-varid'>defaultTyVar</span> <span class='hs-varid'>tv</span>
<a name="line-964"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>promoteTyVar</span> <span class='hs-varid'>tclvl</span> <span class='hs-varid'>tv1</span> <span class='hs-layout'>}</span>
<a name="line-965"></a>
<a name="line-966"></a><a name="defaultTyVar"></a><span class='hs-definition'>defaultTyVar</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVar</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>TcTyVar</span>
<a name="line-967"></a><span class='hs-comment'>-- Precondition: MetaTyVars only</span>
<a name="line-968"></a><span class='hs-comment'>-- See Note [DefaultTyVar]</span>
<a name="line-969"></a><span class='hs-definition'>defaultTyVar</span> <span class='hs-varid'>the_tv</span>
<a name="line-970"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>default_k</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>defaultKind_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarKind</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span>
<a name="line-971"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>tv'</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>cloneMetaTyVar</span> <span class='hs-varid'>the_tv</span>
<a name="line-972"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>new_tv</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>setTyVarKind</span> <span class='hs-varid'>tv'</span> <span class='hs-varid'>default_k</span>
<a name="line-973"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"defaultTyVar"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>the_tv</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>new_tv</span><span class='hs-layout'>)</span>
<a name="line-974"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>the_tv</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>new_tv</span><span class='hs-layout'>)</span>
<a name="line-975"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-varid'>new_tv</span> <span class='hs-layout'>}</span>
<a name="line-976"></a>             <span class='hs-comment'>-- Why not directly derived_pred = mkTcEqPred k default_k?</span>
<a name="line-977"></a>             <span class='hs-comment'>-- See Note [DefaultTyVar]</span>
<a name="line-978"></a>             <span class='hs-comment'>-- We keep the same TcLevel on tv'</span>
<a name="line-979"></a>
<a name="line-980"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-varid'>the_tv</span>    <span class='hs-comment'>-- The common case</span>
<a name="line-981"></a>
<a name="line-982"></a><a name="approximateWC"></a><span class='hs-definition'>approximateWC</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-983"></a><span class='hs-comment'>-- Postcondition: Wanted or Derived Cts</span>
<a name="line-984"></a><span class='hs-comment'>-- See Note [ApproximateWC]</span>
<a name="line-985"></a><span class='hs-definition'>approximateWC</span> <span class='hs-varid'>wc</span>
<a name="line-986"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-varid'>emptyVarSet</span> <span class='hs-varid'>wc</span>
<a name="line-987"></a>  <span class='hs-keyword'>where</span>
<a name="line-988"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-989"></a>    <span class='hs-varid'>float_wc</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span><span class='hs-layout'>,</span> <span class='hs-varid'>wc_impl</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>implics</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-990"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filterBag</span> <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>simples</span> <span class='hs-varop'>`unionBags`</span>
<a name="line-991"></a>        <span class='hs-varid'>do_bag</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_implic</span> <span class='hs-varid'>new_trapping_tvs</span><span class='hs-layout'>)</span> <span class='hs-varid'>implics</span>
<a name="line-992"></a>      <span class='hs-keyword'>where</span>
<a name="line-993"></a>        <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fixVarSet</span> <span class='hs-varid'>grow</span> <span class='hs-varid'>trapping_tvs</span>
<a name="line-994"></a>        <span class='hs-varid'>is_floatable</span> <span class='hs-varid'>ct</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>new_trapping_tvs</span>
<a name="line-995"></a>
<a name="line-996"></a>        <span class='hs-varid'>grow</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-varid'>grow_one</span> <span class='hs-varid'>tvs</span> <span class='hs-varid'>simples</span>
<a name="line-997"></a>        <span class='hs-varid'>grow_one</span> <span class='hs-varid'>ct</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ct_tvs</span> <span class='hs-varop'>`intersectsVarSet`</span> <span class='hs-varid'>tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span> <span class='hs-varop'>`unionVarSet`</span> <span class='hs-varid'>ct_tvs</span>
<a name="line-998"></a>                        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                     <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tvs</span>
<a name="line-999"></a>                        <span class='hs-keyword'>where</span>
<a name="line-1000"></a>                          <span class='hs-varid'>ct_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>ct</span>
<a name="line-1001"></a>
<a name="line-1002"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Implication</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>
<a name="line-1003"></a>    <span class='hs-varid'>float_implic</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-varid'>imp</span>
<a name="line-1004"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>ic_no_eqs</span> <span class='hs-varid'>imp</span>                 <span class='hs-comment'>-- No equalities, so float</span>
<a name="line-1005"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>float_wc</span> <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-layout'>(</span><span class='hs-varid'>ic_wanted</span> <span class='hs-varid'>imp</span><span class='hs-layout'>)</span>
<a name="line-1006"></a>      <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>                     <span class='hs-comment'>-- Don't float out of equalities</span>
<a name="line-1007"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-varid'>emptyCts</span>                      <span class='hs-comment'>-- See Note [ApproximateWC]</span>
<a name="line-1008"></a>      <span class='hs-keyword'>where</span>
<a name="line-1009"></a>        <span class='hs-varid'>new_trapping_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>trapping_tvs</span> <span class='hs-varop'>`extendVarSetList`</span> <span class='hs-varid'>ic_skols</span> <span class='hs-varid'>imp</span>
<a name="line-1010"></a>    <span class='hs-varid'>do_bag</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bag</span> <span class='hs-varid'>c</span>
<a name="line-1011"></a>    <span class='hs-varid'>do_bag</span> <span class='hs-varid'>f</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldrBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>unionBags</span><span class='hs-varop'>.</span><span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-varid'>emptyBag</span>
<a name="line-1012"></a>
<a name="line-1013"></a><span class='hs-comment'>{-
<a name="line-1014"></a>Note [ApproximateWC]
<a name="line-1015"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-1016"></a>approximateWC takes a constraint, typically arising from the RHS of a
<a name="line-1017"></a>let-binding whose type we are *inferring*, and extracts from it some
<a name="line-1018"></a>*simple* constraints that we might plausibly abstract over.  Of course
<a name="line-1019"></a>the top-level simple constraints are plausible, but we also float constraints
<a name="line-1020"></a>out from inside, if they are not captured by skolems.
<a name="line-1021"></a>
<a name="line-1022"></a>The same function is used when doing type-class defaulting (see the call
<a name="line-1023"></a>to applyDefaultingRules) to extract constraints that that might be defaulted.
<a name="line-1024"></a>
<a name="line-1025"></a>There are two caveats:
<a name="line-1026"></a>
<a name="line-1027"></a>1.  We do *not* float anything out if the implication binds equality
<a name="line-1028"></a>    constraints, because that defeats the OutsideIn story.  Consider
<a name="line-1029"></a>       data T a where
<a name="line-1030"></a>         TInt :: T Int
<a name="line-1031"></a>         MkT :: T a
<a name="line-1032"></a>
<a name="line-1033"></a>       f TInt = 3::Int
<a name="line-1034"></a>
<a name="line-1035"></a>    We get the implication (a ~ Int =&gt; res ~ Int), where so far we've decided
<a name="line-1036"></a>      f :: T a -&gt; res
<a name="line-1037"></a>    We don't want to float (res~Int) out because then we'll infer
<a name="line-1038"></a>      f :: T a -&gt; Int
<a name="line-1039"></a>    which is only on of the possible types. (GHC 7.6 accidentally *did*
<a name="line-1040"></a>    float out of such implications, which meant it would happily infer
<a name="line-1041"></a>    non-principal types.)
<a name="line-1042"></a>
<a name="line-1043"></a>2. We do not float out an inner constraint that shares a type variable
<a name="line-1044"></a>   (transitively) with one that is trapped by a skolem.  Eg
<a name="line-1045"></a>       forall a.  F a ~ beta, Integral beta
<a name="line-1046"></a>   We don't want to float out (Integral beta).  Doing so would be bad
<a name="line-1047"></a>   when defaulting, because then we'll default beta:=Integer, and that
<a name="line-1048"></a>   makes the error message much worse; we'd get
<a name="line-1049"></a>       Can't solve  F a ~ Integer
<a name="line-1050"></a>   rather than
<a name="line-1051"></a>       Can't solve  Integral (F a)
<a name="line-1052"></a>
<a name="line-1053"></a>   Moreover, floating out these "contaminated" constraints doesn't help
<a name="line-1054"></a>   when generalising either. If we generalise over (Integral b), we still
<a name="line-1055"></a>   can't solve the retained implication (forall a. F a ~ b).  Indeed,
<a name="line-1056"></a>   arguably that too would be a harder error to understand.
<a name="line-1057"></a>
<a name="line-1058"></a>Note [DefaultTyVar]
<a name="line-1059"></a>~~~~~~~~~~~~~~~~~~~
<a name="line-1060"></a>defaultTyVar is used on any un-instantiated meta type variables to
<a name="line-1061"></a>default the kind of OpenKind and ArgKind etc to *.  This is important
<a name="line-1062"></a>to ensure that instance declarations match.  For example consider
<a name="line-1063"></a>
<a name="line-1064"></a>     instance Show (a-&gt;b)
<a name="line-1065"></a>     foo x = show (\_ -&gt; True)
<a name="line-1066"></a>
<a name="line-1067"></a>Then we'll get a constraint (Show (p -&gt;q)) where p has kind ArgKind,
<a name="line-1068"></a>and that won't match the typeKind (*) in the instance decl.  See tests
<a name="line-1069"></a>tc217 and tc175.
<a name="line-1070"></a>
<a name="line-1071"></a>We look only at touchable type variables. No further constraints
<a name="line-1072"></a>are going to affect these type variables, so it's time to do it by
<a name="line-1073"></a>hand.  However we aren't ready to default them fully to () or
<a name="line-1074"></a>whatever, because the type-class defaulting rules have yet to run.
<a name="line-1075"></a>
<a name="line-1076"></a>An important point is that if the type variable tv has kind k and the
<a name="line-1077"></a>default is default_k we do not simply generate [D] (k ~ default_k) because:
<a name="line-1078"></a>
<a name="line-1079"></a>   (1) k may be ArgKind and default_k may be * so we will fail
<a name="line-1080"></a>
<a name="line-1081"></a>   (2) We need to rewrite all occurrences of the tv to be a type
<a name="line-1082"></a>       variable with the right kind and we choose to do this by rewriting
<a name="line-1083"></a>       the type variable /itself/ by a new variable which does have the
<a name="line-1084"></a>       right kind.
<a name="line-1085"></a>
<a name="line-1086"></a>Note [Promote _and_ default when inferring]
<a name="line-1087"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1088"></a>When we are inferring a type, we simplify the constraint, and then use
<a name="line-1089"></a>approximateWC to produce a list of candidate constraints.  Then we MUST
<a name="line-1090"></a>
<a name="line-1091"></a>  a) Promote any meta-tyvars that have been floated out by
<a name="line-1092"></a>     approximateWC, to restore invariant (MetaTvInv) described in
<a name="line-1093"></a>     Note [TcLevel and untouchable type variables] in TcType.
<a name="line-1094"></a>
<a name="line-1095"></a>  b) Default the kind of any meta-tyyvars that are not mentioned in
<a name="line-1096"></a>     in the environment.
<a name="line-1097"></a>
<a name="line-1098"></a>To see (b), suppose the constraint is (C ((a :: OpenKind) -&gt; Int)), and we
<a name="line-1099"></a>have an instance (C ((x:*) -&gt; Int)).  The instance doesn't match -- but it
<a name="line-1100"></a>should!  If we don't solve the constraint, we'll stupidly quantify over
<a name="line-1101"></a>(C (a-&gt;Int)) and, worse, in doing so zonkQuantifiedTyVar will quantify over
<a name="line-1102"></a>(b:*) instead of (a:OpenKind), which can lead to disaster; see Trac #7332.
<a name="line-1103"></a>Trac #7641 is a simpler example.
<a name="line-1104"></a>
<a name="line-1105"></a>Note [Promoting unification variables]
<a name="line-1106"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1107"></a>When we float an equality out of an implication we must "promote" free
<a name="line-1108"></a>unification variables of the equality, in order to maintain Invariant
<a name="line-1109"></a>(MetaTvInv) from Note [TcLevel and untouchable type variables] in TcType.  for the
<a name="line-1110"></a>leftover implication.
<a name="line-1111"></a>
<a name="line-1112"></a>This is absolutely necessary. Consider the following example. We start
<a name="line-1113"></a>with two implications and a class with a functional dependency.
<a name="line-1114"></a>
<a name="line-1115"></a>    class C x y | x -&gt; y
<a name="line-1116"></a>    instance C [a] [a]
<a name="line-1117"></a>
<a name="line-1118"></a>    (I1)      [untch=beta]forall b. 0 =&gt; F Int ~ [beta]
<a name="line-1119"></a>    (I2)      [untch=beta]forall c. 0 =&gt; F Int ~ [[alpha]] /\ C beta [c]
<a name="line-1120"></a>
<a name="line-1121"></a>We float (F Int ~ [beta]) out of I1, and we float (F Int ~ [[alpha]]) out of I2.
<a name="line-1122"></a>They may react to yield that (beta := [alpha]) which can then be pushed inwards
<a name="line-1123"></a>the leftover of I2 to get (C [alpha] [a]) which, using the FunDep, will mean that
<a name="line-1124"></a>(alpha := a). In the end we will have the skolem 'b' escaping in the untouchable
<a name="line-1125"></a>beta! Concrete example is in indexed_types/should_fail/ExtraTcsUntch.hs:
<a name="line-1126"></a>
<a name="line-1127"></a>    class C x y | x -&gt; y where
<a name="line-1128"></a>     op :: x -&gt; y -&gt; ()
<a name="line-1129"></a>
<a name="line-1130"></a>    instance C [a] [a]
<a name="line-1131"></a>
<a name="line-1132"></a>    type family F a :: *
<a name="line-1133"></a>
<a name="line-1134"></a>    h :: F Int -&gt; ()
<a name="line-1135"></a>    h = undefined
<a name="line-1136"></a>
<a name="line-1137"></a>    data TEx where
<a name="line-1138"></a>      TEx :: a -&gt; TEx
<a name="line-1139"></a>
<a name="line-1140"></a>    f (x::beta) =
<a name="line-1141"></a>        let g1 :: forall b. b -&gt; ()
<a name="line-1142"></a>            g1 _ = h [x]
<a name="line-1143"></a>            g2 z = case z of TEx y -&gt; (h [[undefined]], op x [y])
<a name="line-1144"></a>        in (g1 '3', g2 undefined)
<a name="line-1145"></a>
<a name="line-1146"></a>
<a name="line-1147"></a>Note [Solving Family Equations]
<a name="line-1148"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1149"></a>After we are done with simplification we may be left with constraints of the form:
<a name="line-1150"></a>     [Wanted] F xis ~ beta
<a name="line-1151"></a>If 'beta' is a touchable unification variable not already bound in the TyBinds
<a name="line-1152"></a>then we'd like to create a binding for it, effectively "defaulting" it to be 'F xis'.
<a name="line-1153"></a>
<a name="line-1154"></a>When is it ok to do so?
<a name="line-1155"></a>    1) 'beta' must not already be defaulted to something. Example:
<a name="line-1156"></a>
<a name="line-1157"></a>           [Wanted] F Int  ~ beta   &lt;~ Will default [beta := F Int]
<a name="line-1158"></a>           [Wanted] F Char ~ beta   &lt;~ Already defaulted, can't default again. We
<a name="line-1159"></a>                                       have to report this as unsolved.
<a name="line-1160"></a>
<a name="line-1161"></a>    2) However, we must still do an occurs check when defaulting (F xis ~ beta), to
<a name="line-1162"></a>       set [beta := F xis] only if beta is not among the free variables of xis.
<a name="line-1163"></a>
<a name="line-1164"></a>    3) Notice that 'beta' can't be bound in ty binds already because we rewrite RHS
<a name="line-1165"></a>       of type family equations. See Inert Set invariants in TcInteract.
<a name="line-1166"></a>
<a name="line-1167"></a>This solving is now happening during zonking, see Note [Unflattening while zonking]
<a name="line-1168"></a>in TcMType.
<a name="line-1169"></a>
<a name="line-1170"></a>
<a name="line-1171"></a>*********************************************************************************
<a name="line-1172"></a>*                                                                               *
<a name="line-1173"></a>*                          Floating equalities                                  *
<a name="line-1174"></a>*                                                                               *
<a name="line-1175"></a>*********************************************************************************
<a name="line-1176"></a>
<a name="line-1177"></a>Note [Float Equalities out of Implications]
<a name="line-1178"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1179"></a>For ordinary pattern matches (including existentials) we float
<a name="line-1180"></a>equalities out of implications, for instance:
<a name="line-1181"></a>     data T where
<a name="line-1182"></a>       MkT :: Eq a =&gt; a -&gt; T
<a name="line-1183"></a>     f x y = case x of MkT _ -&gt; (y::Int)
<a name="line-1184"></a>We get the implication constraint (x::T) (y::alpha):
<a name="line-1185"></a>     forall a. [untouchable=alpha] Eq a =&gt; alpha ~ Int
<a name="line-1186"></a>We want to float out the equality into a scope where alpha is no
<a name="line-1187"></a>longer untouchable, to solve the implication!
<a name="line-1188"></a>
<a name="line-1189"></a>But we cannot float equalities out of implications whose givens may
<a name="line-1190"></a>yield or contain equalities:
<a name="line-1191"></a>
<a name="line-1192"></a>      data T a where
<a name="line-1193"></a>        T1 :: T Int
<a name="line-1194"></a>        T2 :: T Bool
<a name="line-1195"></a>        T3 :: T a
<a name="line-1196"></a>
<a name="line-1197"></a>      h :: T a -&gt; a -&gt; Int
<a name="line-1198"></a>
<a name="line-1199"></a>      f x y = case x of
<a name="line-1200"></a>                T1 -&gt; y::Int
<a name="line-1201"></a>                T2 -&gt; y::Bool
<a name="line-1202"></a>                T3 -&gt; h x y
<a name="line-1203"></a>
<a name="line-1204"></a>We generate constraint, for (x::T alpha) and (y :: beta):
<a name="line-1205"></a>   [untouchables = beta] (alpha ~ Int =&gt; beta ~ Int)   -- From 1st branch
<a name="line-1206"></a>   [untouchables = beta] (alpha ~ Bool =&gt; beta ~ Bool) -- From 2nd branch
<a name="line-1207"></a>   (alpha ~ beta)                                      -- From 3rd branch
<a name="line-1208"></a>
<a name="line-1209"></a>If we float the equality (beta ~ Int) outside of the first implication and
<a name="line-1210"></a>the equality (beta ~ Bool) out of the second we get an insoluble constraint.
<a name="line-1211"></a>But if we just leave them inside the implications we unify alpha := beta and
<a name="line-1212"></a>solve everything.
<a name="line-1213"></a>
<a name="line-1214"></a>Principle:
<a name="line-1215"></a>    We do not want to float equalities out which may
<a name="line-1216"></a>    need the given *evidence* to become soluble.
<a name="line-1217"></a>
<a name="line-1218"></a>Consequence: classes with functional dependencies don't matter (since there is
<a name="line-1219"></a>no evidence for a fundep equality), but equality superclasses do matter (since
<a name="line-1220"></a>they carry evidence).
<a name="line-1221"></a>-}</span>
<a name="line-1222"></a>
<a name="line-1223"></a><a name="floatEqualities"></a><span class='hs-definition'>floatEqualities</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>TcTyVar</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1224"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>WantedConstraints</span>
<a name="line-1225"></a>                <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-layout'>(</span><span class='hs-conid'>Cts</span><span class='hs-layout'>,</span> <span class='hs-conid'>WantedConstraints</span><span class='hs-layout'>)</span>
<a name="line-1226"></a><span class='hs-comment'>-- Main idea: see Note [Float Equalities out of Implications]</span>
<a name="line-1227"></a><span class='hs-comment'>--</span>
<a name="line-1228"></a><span class='hs-comment'>-- Precondition: the wc_simple of the incoming WantedConstraints are</span>
<a name="line-1229"></a><span class='hs-comment'>--               fully zonked, so that we can see their free variables</span>
<a name="line-1230"></a><span class='hs-comment'>--</span>
<a name="line-1231"></a><span class='hs-comment'>-- Postcondition: The returned floated constraints (Cts) are only</span>
<a name="line-1232"></a><span class='hs-comment'>--                Wanted or Derived and come from the input wanted</span>
<a name="line-1233"></a><span class='hs-comment'>--                ev vars or deriveds</span>
<a name="line-1234"></a><span class='hs-comment'>--</span>
<a name="line-1235"></a><span class='hs-comment'>-- Also performs some unifications (via promoteTyVar), adding to</span>
<a name="line-1236"></a><span class='hs-comment'>-- monadically-carried ty_binds. These will be used when processing</span>
<a name="line-1237"></a><span class='hs-comment'>-- floated_eqs later</span>
<a name="line-1238"></a><span class='hs-comment'>--</span>
<a name="line-1239"></a><span class='hs-comment'>-- Subtleties: Note [Float equalities from under a skolem binding]</span>
<a name="line-1240"></a><span class='hs-comment'>--             Note [Skolem escape]</span>
<a name="line-1241"></a><span class='hs-definition'>floatEqualities</span> <span class='hs-varid'>skols</span> <span class='hs-varid'>no_given_eqs</span> <span class='hs-varid'>wanteds</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>WC</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>simples</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span>
<a name="line-1242"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>not</span> <span class='hs-varid'>no_given_eqs</span>  <span class='hs-comment'>-- There are some given equalities, so don't float</span>
<a name="line-1243"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>emptyBag</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- Note [Float Equalities out of Implications]</span>
<a name="line-1244"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1245"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>outer_tclvl</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>getTcLevel</span>
<a name="line-1246"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>mapM_</span> <span class='hs-layout'>(</span><span class='hs-varid'>promoteTyVar</span> <span class='hs-varid'>outer_tclvl</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>varSetElems</span> <span class='hs-layout'>(</span><span class='hs-varid'>tyVarsOfCts</span> <span class='hs-varid'>float_eqs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1247"></a>             <span class='hs-comment'>-- See Note [Promoting unification variables]</span>
<a name="line-1248"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"floatEqualities"</span> <span class='hs-layout'>(</span><span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Skols ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>skols</span>
<a name="line-1249"></a>                                          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Simples ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>simples</span>
<a name="line-1250"></a>                                          <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"Floated eqs ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>float_eqs</span> <span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1251"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>float_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>wanteds</span> <span class='hs-layout'>{</span> <span class='hs-varid'>wc_simple</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>remaining_simples</span> <span class='hs-layout'>}</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1252"></a>  <span class='hs-keyword'>where</span>
<a name="line-1253"></a>    <span class='hs-varid'>skol_set</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mkVarSet</span> <span class='hs-varid'>skols</span>
<a name="line-1254"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>float_eqs</span><span class='hs-layout'>,</span> <span class='hs-varid'>remaining_simples</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionBag</span> <span class='hs-varid'>float_me</span> <span class='hs-varid'>simples</span>
<a name="line-1255"></a>
<a name="line-1256"></a>    <span class='hs-varid'>float_me</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Ct</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-1257"></a>    <span class='hs-varid'>float_me</span> <span class='hs-varid'>ct</span>   <span class='hs-comment'>-- The constraint is un-flattened and de-cannonicalised</span>
<a name="line-1258"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>pred</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>ctPred</span> <span class='hs-varid'>ct</span>
<a name="line-1259"></a>       <span class='hs-layout'>,</span> <span class='hs-conid'>EqPred</span> <span class='hs-conid'>NomEq</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>classifyPredType</span> <span class='hs-varid'>pred</span>
<a name="line-1260"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>tyVarsOfType</span> <span class='hs-varid'>pred</span> <span class='hs-varop'>`disjointVarSet`</span> <span class='hs-varid'>skol_set</span>
<a name="line-1261"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>useful_to_float</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1262"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>True</span>
<a name="line-1263"></a>       <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1264"></a>       <span class='hs-keyglyph'>=</span> <span class='hs-conid'>False</span>
<a name="line-1265"></a>
<a name="line-1266"></a>      <span class='hs-comment'>-- Float out alpha ~ ty, or ty ~ alpha</span>
<a name="line-1267"></a>      <span class='hs-comment'>-- which might be unified outside</span>
<a name="line-1268"></a>      <span class='hs-comment'>-- See Note [Do not float kind-incompatible equalities]</span>
<a name="line-1269"></a>    <span class='hs-varid'>useful_to_float</span> <span class='hs-varid'>ty1</span> <span class='hs-varid'>ty2</span>
<a name="line-1270"></a>      <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>case</span> <span class='hs-layout'>(</span><span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty1</span><span class='hs-layout'>,</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty2</span><span class='hs-layout'>)</span> <span class='hs-keyword'>of</span>
<a name="line-1271"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>tv1</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv1</span>
<a name="line-1272"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>k2</span> <span class='hs-varop'>`isSubKind`</span> <span class='hs-varid'>k1</span>
<a name="line-1273"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1274"></a>          <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv2</span>
<a name="line-1275"></a>                        <span class='hs-layout'>,</span> <span class='hs-varid'>k1</span> <span class='hs-varop'>`isSubKind`</span> <span class='hs-varid'>k2</span>
<a name="line-1276"></a>                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>True</span>
<a name="line-1277"></a>          <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>False</span>
<a name="line-1278"></a>      <span class='hs-keyword'>where</span>
<a name="line-1279"></a>        <span class='hs-varid'>k1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty1</span>
<a name="line-1280"></a>        <span class='hs-varid'>k2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>typeKind</span> <span class='hs-varid'>ty2</span>
<a name="line-1281"></a>
<a name="line-1282"></a><span class='hs-comment'>{-
<a name="line-1283"></a>Note [Do not float kind-incompatible equalities]
<a name="line-1284"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1285"></a>If we have (t::* ~ s::*-&gt;*), we'll get a Derived insoluble equality.
<a name="line-1286"></a>If we float the equality outwards, we'll get *another* Derived
<a name="line-1287"></a>insoluble equality one level out, so the same error will be reported
<a name="line-1288"></a>twice.  So we refrain from floating such equalities
<a name="line-1289"></a>
<a name="line-1290"></a>Note [Float equalities from under a skolem binding]
<a name="line-1291"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1292"></a>Which of the simple equalities can we float out?  Obviously, only
<a name="line-1293"></a>ones that don't mention the skolem-bound variables.  But that is
<a name="line-1294"></a>over-eager. Consider
<a name="line-1295"></a>   [2] forall a. F a beta[1] ~ gamma[2], G beta[1] gamma[2] ~ Int
<a name="line-1296"></a>The second constraint doesn't mention 'a'.  But if we float it
<a name="line-1297"></a>we'll promote gamma[2] to gamma'[1].  Now suppose that we learn that
<a name="line-1298"></a>beta := Bool, and F a Bool = a, and G Bool _ = Int.  Then we'll
<a name="line-1299"></a>we left with the constraint
<a name="line-1300"></a>   [2] forall a. a ~ gamma'[1]
<a name="line-1301"></a>which is insoluble because gamma became untouchable.
<a name="line-1302"></a>
<a name="line-1303"></a>Solution: float only constraints that stand a jolly good chance of
<a name="line-1304"></a>being soluble simply by being floated, namely ones of form
<a name="line-1305"></a>      a ~ ty
<a name="line-1306"></a>where 'a' is a currently-untouchable unification variable, but may
<a name="line-1307"></a>become touchable by being floated (perhaps by more than one level).
<a name="line-1308"></a>
<a name="line-1309"></a>We had a very complicated rule previously, but this is nice and
<a name="line-1310"></a>simple.  (To see the notes, look at this Note in a version of
<a name="line-1311"></a>TcSimplify prior to Oct 2014).
<a name="line-1312"></a>
<a name="line-1313"></a>Note [Skolem escape]
<a name="line-1314"></a>~~~~~~~~~~~~~~~~~~~~
<a name="line-1315"></a>You might worry about skolem escape with all this floating.
<a name="line-1316"></a>For example, consider
<a name="line-1317"></a>    [2] forall a. (a ~ F beta[2] delta,
<a name="line-1318"></a>                   Maybe beta[2] ~ gamma[1])
<a name="line-1319"></a>
<a name="line-1320"></a>The (Maybe beta ~ gamma) doesn't mention 'a', so we float it, and
<a name="line-1321"></a>solve with gamma := beta. But what if later delta:=Int, and
<a name="line-1322"></a>  F b Int = b.
<a name="line-1323"></a>Then we'd get a ~ beta[2], and solve to get beta:=a, and now the
<a name="line-1324"></a>skolem has escaped!
<a name="line-1325"></a>
<a name="line-1326"></a>But it's ok: when we float (Maybe beta[2] ~ gamma[1]), we promote beta[2]
<a name="line-1327"></a>to beta[1], and that means the (a ~ beta[1]) will be stuck, as it should be.
<a name="line-1328"></a>
<a name="line-1329"></a>
<a name="line-1330"></a>*********************************************************************************
<a name="line-1331"></a>*                                                                               *
<a name="line-1332"></a>*                          Defaulting and disamgiguation                        *
<a name="line-1333"></a>*                                                                               *
<a name="line-1334"></a>*********************************************************************************
<a name="line-1335"></a>-}</span>
<a name="line-1336"></a>
<a name="line-1337"></a><a name="applyDefaultingRules"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Cts</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>
<a name="line-1338"></a>  <span class='hs-comment'>-- True &lt;=&gt; I did some defaulting, reflected in ty_binds</span>
<a name="line-1339"></a>
<a name="line-1340"></a><span class='hs-comment'>-- Return some extra derived equalities, which express the</span>
<a name="line-1341"></a><span class='hs-comment'>-- type-class default choice.</span>
<a name="line-1342"></a><span class='hs-definition'>applyDefaultingRules</span> <span class='hs-varid'>wanteds</span>
<a name="line-1343"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isEmptyBag</span> <span class='hs-varid'>wanteds</span>
<a name="line-1344"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-1345"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>
<a name="line-1346"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules { "</span> <span class='hs-varop'>$</span>
<a name="line-1347"></a>                  <span class='hs-varid'>text</span> <span class='hs-str'>"wanteds ="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>wanteds</span>
<a name="line-1348"></a>
<a name="line-1349"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>info</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getDefaultInfo</span>
<a name="line-1350"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>groups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>findDefaultableGroups</span> <span class='hs-varid'>info</span> <span class='hs-varid'>wanteds</span>
<a name="line-1351"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"findDefaultableGroups"</span> <span class='hs-varop'>$</span> <span class='hs-varid'>vcat</span> <span class='hs-keyglyph'>[</span> <span class='hs-varid'>text</span> <span class='hs-str'>"groups="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>groups</span>
<a name="line-1352"></a>                                                 <span class='hs-layout'>,</span> <span class='hs-varid'>text</span> <span class='hs-str'>"info="</span> <span class='hs-varop'>&lt;+&gt;</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>info</span> <span class='hs-keyglyph'>]</span>
<a name="line-1353"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>something_happeneds</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>mapM</span> <span class='hs-layout'>(</span><span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>groups</span>
<a name="line-1354"></a>
<a name="line-1355"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"applyDefaultingRules }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>something_happeneds</span><span class='hs-layout'>)</span>
<a name="line-1356"></a>
<a name="line-1357"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>or</span> <span class='hs-varid'>something_happeneds</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1358"></a>
<a name="line-1359"></a><a name="findDefaultableGroups"></a><span class='hs-definition'>findDefaultableGroups</span>
<a name="line-1360"></a>    <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>
<a name="line-1361"></a>       <span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-conid'>Bool</span><span class='hs-layout'>,</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-layout'>)</span>  <span class='hs-comment'>-- (Overloaded strings, extended default rules)</span>
<a name="line-1362"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Cts</span>              <span class='hs-comment'>-- Unsolved (wanted or derived)</span>
<a name="line-1363"></a>    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span><span class='hs-conid'>Class</span><span class='hs-layout'>,</span><span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>
<a name="line-1364"></a><span class='hs-definition'>findDefaultableGroups</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>,</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span><span class='hs-layout'>,</span> <span class='hs-varid'>extended_defaults</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varid'>wanteds</span>
<a name="line-1365"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>null</span> <span class='hs-varid'>default_tys</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-1366"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultable_groups</span>
<a name="line-1367"></a>  <span class='hs-keyword'>where</span>
<a name="line-1368"></a>    <span class='hs-varid'>defaultable_groups</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-varid'>is_defaultable_group</span> <span class='hs-varid'>groups</span>
<a name="line-1369"></a>    <span class='hs-varid'>groups</span>             <span class='hs-keyglyph'>=</span> <span class='hs-varid'>equivClasses</span> <span class='hs-varid'>cmp_tv</span> <span class='hs-varid'>unaries</span>
<a name="line-1370"></a>    <span class='hs-varid'>unaries</span>     <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- (C tv) constraints</span>
<a name="line-1371"></a>    <span class='hs-varid'>non_unaries</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Ct</span><span class='hs-keyglyph'>]</span>             <span class='hs-comment'>-- and *other* constraints</span>
<a name="line-1372"></a>
<a name="line-1373"></a>    <span class='hs-layout'>(</span><span class='hs-varid'>unaries</span><span class='hs-layout'>,</span> <span class='hs-varid'>non_unaries</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>partitionWith</span> <span class='hs-varid'>find_unary</span> <span class='hs-layout'>(</span><span class='hs-varid'>bagToList</span> <span class='hs-varid'>wanteds</span><span class='hs-layout'>)</span>
<a name="line-1374"></a>        <span class='hs-comment'>-- Finds unary type-class constraints</span>
<a name="line-1375"></a>        <span class='hs-comment'>-- But take account of polykinded classes like Typeable,</span>
<a name="line-1376"></a>        <span class='hs-comment'>-- which may look like (Typeable * (a:*))   (Trac #8931)</span>
<a name="line-1377"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span>
<a name="line-1378"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span><span class='hs-layout'>,</span><span class='hs-varid'>tys</span><span class='hs-layout'>)</span>   <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>getClassPredTys_maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>ctPred</span> <span class='hs-varid'>cc</span><span class='hs-layout'>)</span>
<a name="line-1379"></a>        <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-layout'>(</span><span class='hs-varid'>kinds</span><span class='hs-layout'>,</span> <span class='hs-varid'>ty</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>snocView</span> <span class='hs-varid'>tys</span>
<a name="line-1380"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>all</span> <span class='hs-varid'>isKind</span> <span class='hs-varid'>kinds</span>
<a name="line-1381"></a>        <span class='hs-layout'>,</span> <span class='hs-conid'>Just</span> <span class='hs-varid'>tv</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>tcGetTyVar_maybe</span> <span class='hs-varid'>ty</span>
<a name="line-1382"></a>        <span class='hs-layout'>,</span> <span class='hs-varid'>isMetaTyVar</span> <span class='hs-varid'>tv</span>  <span class='hs-comment'>-- We might have runtime-skolems in GHCi, and</span>
<a name="line-1383"></a>                          <span class='hs-comment'>-- we definitely don't want to try to assign to those!</span>
<a name="line-1384"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-varid'>cc</span><span class='hs-layout'>,</span> <span class='hs-varid'>cls</span><span class='hs-layout'>,</span> <span class='hs-varid'>tv</span><span class='hs-layout'>)</span>
<a name="line-1385"></a>    <span class='hs-varid'>find_unary</span> <span class='hs-varid'>cc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Right</span> <span class='hs-varid'>cc</span>  <span class='hs-comment'>-- Non unary or non dictionary</span>
<a name="line-1386"></a>
<a name="line-1387"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>TcTyVarSet</span>  <span class='hs-comment'>-- TyVars mentioned by non-unaries</span>
<a name="line-1388"></a>    <span class='hs-varid'>bad_tvs</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>mapUnionVarSet</span> <span class='hs-varid'>tyVarsOfCt</span> <span class='hs-varid'>non_unaries</span>
<a name="line-1389"></a>
<a name="line-1390"></a>    <span class='hs-varid'>cmp_tv</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv1</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv2</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>tv1</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>tv2</span>
<a name="line-1391"></a>
<a name="line-1392"></a>    <span class='hs-varid'>is_defaultable_group</span> <span class='hs-varid'>ds</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>tv</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span>
<a name="line-1393"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>b1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isTyConableTyVar</span> <span class='hs-varid'>tv</span>  <span class='hs-comment'>-- Note [Avoiding spurious errors]</span>
<a name="line-1394"></a>              <span class='hs-varid'>b2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>tv</span> <span class='hs-varop'>`elemVarSet`</span> <span class='hs-varid'>bad_tvs</span><span class='hs-layout'>)</span>
<a name="line-1395"></a>              <span class='hs-varid'>b4</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>defaultable_classes</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>cls</span> <span class='hs-keyglyph'>|</span> <span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>cls</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>ds</span><span class='hs-keyglyph'>]</span>
<a name="line-1396"></a>          <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>b1</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b2</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-varid'>b4</span><span class='hs-layout'>)</span>
<a name="line-1397"></a>    <span class='hs-varid'>is_defaultable_group</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"defaultable_group"</span>
<a name="line-1398"></a>
<a name="line-1399"></a>    <span class='hs-varid'>defaultable_classes</span> <span class='hs-varid'>clss</span>
<a name="line-1400"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>extended_defaults</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>any</span> <span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>clss</span>
<a name="line-1401"></a>        <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span>         <span class='hs-keyglyph'>=</span> <span class='hs-varid'>all</span> <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>clss</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>any</span> <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>clss</span><span class='hs-layout'>)</span>
<a name="line-1402"></a>
<a name="line-1403"></a>    <span class='hs-comment'>-- In interactive mode, or with -XExtendedDefaultRules,</span>
<a name="line-1404"></a>    <span class='hs-comment'>-- we default Show a to Show () to avoid graututious errors on "show []"</span>
<a name="line-1405"></a>    <span class='hs-varid'>isInteractiveClass</span> <span class='hs-varid'>cls</span>
<a name="line-1406"></a>        <span class='hs-keyglyph'>=</span> <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>classKey</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>`elem`</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>showClassKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>eqClassKey</span><span class='hs-layout'>,</span> <span class='hs-varid'>ordClassKey</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-1407"></a>
<a name="line-1408"></a>    <span class='hs-varid'>is_num_class</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isNumericClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1409"></a>    <span class='hs-comment'>-- is_num_class adds IsString to the standard numeric classes,</span>
<a name="line-1410"></a>    <span class='hs-comment'>-- when -foverloaded-strings is enabled</span>
<a name="line-1411"></a>
<a name="line-1412"></a>    <span class='hs-varid'>is_std_class</span> <span class='hs-varid'>cls</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>isStandardClass</span> <span class='hs-varid'>cls</span> <span class='hs-varop'>||</span> <span class='hs-layout'>(</span><span class='hs-varid'>ovl_strings</span> <span class='hs-varop'>&amp;&amp;</span> <span class='hs-layout'>(</span><span class='hs-varid'>cls</span> <span class='hs-varop'>`hasKey`</span> <span class='hs-varid'>isStringClassKey</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-1413"></a>    <span class='hs-comment'>-- Similarly is_std_class</span>
<a name="line-1414"></a>
<a name="line-1415"></a><a name="disambigGroup"></a><span class='hs-comment'>------------------------------</span>
<a name="line-1416"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-keyglyph'>::</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Type</span><span class='hs-keyglyph'>]</span>                  <span class='hs-comment'>-- The default types</span>
<a name="line-1417"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Ct</span><span class='hs-layout'>,</span> <span class='hs-conid'>Class</span><span class='hs-layout'>,</span> <span class='hs-conid'>TcTyVar</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>  <span class='hs-comment'>-- All classes of the form (C a)</span>
<a name="line-1418"></a>                                         <span class='hs-comment'>--  sharing same type variable</span>
<a name="line-1419"></a>              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>TcS</span> <span class='hs-conid'>Bool</span>   <span class='hs-comment'>-- True &lt;=&gt; something happened, reflected in ty_binds</span>
<a name="line-1420"></a>
<a name="line-1421"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-conid'>[]</span>  <span class='hs-sel'>_grp</span>
<a name="line-1422"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-varid'>return</span> <span class='hs-conid'>False</span>
<a name="line-1423"></a><span class='hs-definition'>disambigGroup</span> <span class='hs-layout'>(</span><span class='hs-varid'>default_ty</span><span class='hs-conop'>:</span><span class='hs-varid'>default_tys</span><span class='hs-layout'>)</span> <span class='hs-varid'>group</span>
<a name="line-1424"></a>  <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup {"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>group</span> <span class='hs-varop'>$$</span> <span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-1425"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>fake_ev_binds_var</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>newTcEvBinds</span>
<a name="line-1426"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>given_ev_var</span>      <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>newEvVar</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTcEqPred</span> <span class='hs-layout'>(</span><span class='hs-varid'>mkTyVarTy</span> <span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-1427"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>tclvl</span>             <span class='hs-keyglyph'>&lt;-</span> <span class='hs-conid'>TcS</span><span class='hs-varop'>.</span><span class='hs-varid'>getTcLevel</span>
<a name="line-1428"></a>       <span class='hs-layout'>;</span> <span class='hs-varid'>success</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nestImplicTcS</span> <span class='hs-varid'>fake_ev_binds_var</span> <span class='hs-layout'>(</span><span class='hs-varid'>pushTcLevel</span> <span class='hs-varid'>tclvl</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span>
<a name="line-1429"></a>                    <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>solveSimpleGivens</span> <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>given_ev_var</span><span class='hs-keyglyph'>]</span>
<a name="line-1430"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>residual_wanted</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>solveSimpleWanteds</span> <span class='hs-varid'>wanteds</span>
<a name="line-1431"></a>                       <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-layout'>(</span><span class='hs-varid'>isEmptyWC</span> <span class='hs-varid'>residual_wanted</span><span class='hs-layout'>)</span> <span class='hs-layout'>}</span>
<a name="line-1432"></a>
<a name="line-1433"></a>       <span class='hs-layout'>;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>success</span> <span class='hs-keyword'>then</span>
<a name="line-1434"></a>             <span class='hs-comment'>-- Success: record the type variable binding, and return</span>
<a name="line-1435"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>setWantedTyBind</span> <span class='hs-varid'>the_tv</span> <span class='hs-varid'>default_ty</span>
<a name="line-1436"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>wrapWarnTcS</span> <span class='hs-varop'>$</span> <span class='hs-varid'>warnDefaulting</span> <span class='hs-varid'>wanteds</span> <span class='hs-varid'>default_ty</span>
<a name="line-1437"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup succeeded }"</span> <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-1438"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>return</span> <span class='hs-conid'>True</span> <span class='hs-layout'>}</span>
<a name="line-1439"></a>         <span class='hs-keyword'>else</span>
<a name="line-1440"></a>             <span class='hs-comment'>-- Failure: try with the next type</span>
<a name="line-1441"></a>             <span class='hs-keyword'>do</span> <span class='hs-layout'>{</span> <span class='hs-varid'>traceTcS</span> <span class='hs-str'>"disambigGroup failed, will try other default types }"</span>
<a name="line-1442"></a>                           <span class='hs-layout'>(</span><span class='hs-varid'>ppr</span> <span class='hs-varid'>default_ty</span><span class='hs-layout'>)</span>
<a name="line-1443"></a>                <span class='hs-layout'>;</span> <span class='hs-varid'>disambigGroup</span> <span class='hs-varid'>default_tys</span> <span class='hs-varid'>group</span> <span class='hs-layout'>}</span> <span class='hs-layout'>}</span>
<a name="line-1444"></a>  <span class='hs-keyword'>where</span>
<a name="line-1445"></a>    <span class='hs-varid'>wanteds</span>          <span class='hs-keyglyph'>=</span> <span class='hs-varid'>listToBag</span> <span class='hs-layout'>(</span><span class='hs-varid'>map</span> <span class='hs-varid'>fstOf3</span> <span class='hs-varid'>group</span><span class='hs-layout'>)</span>
<a name="line-1446"></a>    <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>,</span><span class='hs-varid'>the_tv</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>group</span>
<a name="line-1447"></a>    <span class='hs-varid'>loc</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>CtLoc</span> <span class='hs-layout'>{</span> <span class='hs-varid'>ctl_origin</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>GivenOrigin</span> <span class='hs-conid'>UnkSkol</span>
<a name="line-1448"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>ctl_env</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>panic</span> <span class='hs-str'>"disambigGroup:env"</span>
<a name="line-1449"></a>                <span class='hs-layout'>,</span> <span class='hs-varid'>ctl_depth</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>initialSubGoalDepth</span> <span class='hs-layout'>}</span>
<a name="line-1450"></a>
<a name="line-1451"></a><span class='hs-comment'>{-
<a name="line-1452"></a>Note [Avoiding spurious errors]
<a name="line-1453"></a>~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<a name="line-1454"></a>When doing the unification for defaulting, we check for skolem
<a name="line-1455"></a>type variables, and simply don't default them.  For example:
<a name="line-1456"></a>   f = (*)      -- Monomorphic
<a name="line-1457"></a>   g :: Num a =&gt; a -&gt; a
<a name="line-1458"></a>   g x = f x x
<a name="line-1459"></a>Here, we get a complaint when checking the type signature for g,
<a name="line-1460"></a>that g isn't polymorphic enough; but then we get another one when
<a name="line-1461"></a>dealing with the (Num a) context arising from f's definition;
<a name="line-1462"></a>we try to unify a with Int (to default it), but find that it's
<a name="line-1463"></a>already been unified with the rigid variable from g's type sig
<a name="line-1464"></a>-}</span>
</pre></body>
</html>
